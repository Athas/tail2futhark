\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}
\usepackage{cite}
\usepackage{stmaryrd}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{tabu}

\lstset{
  mathescape,
  moredelim=[is][\underbar]{_}{_}
}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn \& Henriks Urms}\\
  \\ \textit{Supervisor:} Martin Elsman
  % \texttt{a.kiehn89@gmail.com} \\
  %\\ \texttt{a.kiehn89@gmail.com} \\ \\
  %\Large{Henriks Urms}
  %\\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{5cm}
  \Huge{Bachelor's thesis} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}
%\renewcommand{\arraystretch}{1.2}

\newcommand{\evals}[1]{\llbracket #1 \rrbracket}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/natbio-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/natbio-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/nat-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\abstract

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  REPORT STARTS HERE  %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The intermidiate language TAIL}

TAIL is a typed array intermediate language and the target of an APL compiler.
APL is an older language created in the 1960's by Kenneth E. Iverson.
APL is an array programming language, its main type is the multi-dimensional array 
and most of the built-in functions in the language are array operators that work on this type. 
All of its built-in functions or operators are represented by unicode symbols allowing for very concise code.
The APL language is dynamically typed. It supports first and second order functions and it supports polymorphism in 
both its first and second order functions and operators. 
Even though it is not a new language it is still used in the financial world 
where large code bases are still operational and actively developed \cite{ElsmanDybdal:Array:2014}. \\



TAIL was designed with the purpose of targeting parallel architectures, though no parallel backend for TAIL yet exists.
Another backend to TAIL exists however which compile TAIL efficiently into a C-like language. TAIL does not support
 all APLs operators but only a subset of these \cite{ElsmanDybdal:Array:2014}. 
The subset of APL operators that TAIL support result in the following TAIL build-in operators:

\begin{lstlisting}[numbers=none,frame=none]
op ::= addi | subi | multi | mini | maxi | addd | subd | 
       muld | mind | maxd | andb | orb | xorb |  nanb | 
       norb | notb | lti | ltei | gti | gtei | eqi | neqi |
       ltd | lted | gtd | gted | eqd | neqd | iota | each |
       reduce | i2d | b2i | reshape0 | reshape | rotate |
       transp | transp2 | zipWith | shape | take | drop |
       first | cat | cons | snoc | shapeV | catV | consV | 
       snocV | iotaV | rotateV | takeV | dropV | firstV 
\end{lstlisting}

The 'V' following some of the operators indicate they are a special version of the operator that works on vectors. \\

% In APL indexing are done with 1-indexing but it is possible to change the indexing to 0-indexing on the fly. 

The central type in TAIL is, like in APL, the multi-dimensional array type. The array type consist of a base type and a rank. The rank are represented as a vector consisting of the dimentions of the array.
The base type of an array is the type of the elements in the array and can currently be of the
type: {\tt int}, {\tt double}, {\tt bool} {\tt char}. 
Scalars are a special case of the array type and is represented as an array of rank 0.
Vectors can be represented in two different ways in TAIL.
Either as an array of rank 1 or as the special vector type.
The special vector type is used for vector literals where the length of the vector is known at compile time \cite{ElsmanDybdal:Array:2014}. \\

Some of the operators take types as part of their constructor in form of an instance decleration. 
The instance decleration consist of a basic type and a vector that either tells the ranks of 
the resulting array or the length (number of elements) of the one dimentional array (vector).\\

Most of the operators in TAIL are polymorphic in respect to array ranks and base types.
Some of them only take some polymorphic arguments but also take specific type arguments.
An example is the {\tt take} function. It takes as argument a number (of type int) and an array of type $\alpha$.\\

 TAILs type system takes the parallelism of APL and transforms it to a more manageable form adding explicit type
 information to the constructs.
Another benefit of the expressivity of TAILs type system is that it allows the (TAIL) compiler to express some operators which
are primitive in APL using simpler operators, one such operator is that of the inner product \cite{ElsmanDybdal:Array:2014}. \\

There are four parallel operators in TAIL, {\tt each}, {\tt eachV}, {\tt reduce} and {\tt zipWith}.
The functions {\tt each} and {\tt eachV} are known in many languages as map.
The function takes two arguments: a function and an array and then apply this function on the array.
If the rank of the array is greater than 1 the {\tt each} function work as a map on the fattened representation of the array,
that is, the function is applied on the inner most dimension of the array.
The {\tt eachV} function is a special case of {\tt each} and is used on the special vector type.\\

The function {\tt reduce} works similar to fold known in functional languages.
Their function takes as arguments a associative binary operator, a neutral element and array.
The {\tt reduce} function the uses the binary operator 
to reduce an array of rank $\gamma+1$ to an array of rank $\gamma$ by reducing along the inner-most dimension.
The difference to fold is that the operator has to be associative and the start element has to be neutral
because the execution is parallel.

The {\tt zipWith} function takes as arguments a function and two arrays.
It then applies the function on the pair of elements consisting of the i'th element
from the first array and the i'th element from the second array.
Like the other tree operators it works on the inner-most dimension of the array\cite{ElsmanDybdal:Array:2014}.

A TAIL programs always consist of a single expression. An expression can then be a value, variable, 
list of expressions, a let expression or an operator.

The aplacc parser for TAIL represents the TAIL expressions in the apstract syntax tree as variables, constants, infinity, the negative representation of 
the expression, let expressions, operators and lambda expressions. 
\begin{lstlisting}[numbers=none,frame=none]
e ::= x | i | d | c | inf | -e | let x:$t$ = e$_1$ in e$_2$ |
      op[e$_1$,...,e$_n$] | fn x:$t$ e | [e$_1$,...,e$_n$]
\end{lstlisting}

The $t$'s are types that are part of the expression. \\

TAIL does not support curried functions but require functions to be fully applied.\\

NB!! we use both the word function and operator about the same thing. Should we distinguish?



 %\cite{TorbenMogensen}. \\



%%If we do not show the type schemes here we should reference to where they can be found in the article!!!!!!!!!!

%The types in TAIL are divided into four types. Firstly there are base types consisting of {\tt int}, {\tt double}, {\tt bool} and the polymorphic type {\tt $\alpha$} that can represent any one of them. Secondly, there are shape types that can be either a scalar value/variable of type int,  or a shape variable or a combination of two shape variables. \\
%Then there is array types that consist of a base type and a rank. Finally there is 


%The main datatype in TAIL is also a multidimensional array. Array types are in TAIL annotated with their ranks explicitly. 
%TAILs type system treats scalar values as special cases of the array time namely an array with rank 0. 

%There are two separate representations of vectors, either the special vector type used when the length of the vector is known or the general array type where the rank is 1.  
 
%Besides array and vector types, TAIL also have base types in the form of {\tt int}, {\tt double}, {\tt bool} and {\tt $\alpha$}.

%So far TAIL only support a subset of the APL functions and operators. 

\newpage

\section{The functional language Futhark}

Futhark is a functional programming language inspired by Haskell and Standard ML.
It was designed to be an attractive choice for expressing complex programs by having enough expressive power without
losing the possibility to do aggressive optimization and creating parallelism even though the higher the expressive power of the
language the more difficult optimization often become.
Due to the focus on optimization the Futhark language only supports regular arrays
(arrays where all inner dimensions are of the same length)
because of the complication to size analysis if the language had supported non-regular arrays would have create.
However Futhark do support nested parallelism as this is a feature many programs 
depend upon even though this feature does make optimization more difficult \cite{TroelsHenriksen}.
Indentation has no syntactical importance in the Futhark language. \\

%%something more about specific optimization????????????????\\

% funktioner bliver inlinet

A Futhark program consist of a list of function declarations of the form:
\begin{lstlisting}[numbers=none,frame=none]
fun return-type name(params...) = body
\end{lstlisting}
The body of the Futhark function then consist of an expression. 

The Futhark expressions can be found in the scheme below. They are among other constants, variables, binary- and other build-in operators and let expressions.

\begin{lstlisting}[numbers=none,frame=none]
e ::= k | v | {e$_1$,...,e$_n$} | [e$_1$,...,e$_n$] | e$_1$ $\odot$ e$_2$ |
      -e | not e | if e$_1$ then e$_2$ else e$_3$ | v[e$_1$,...,e$_n$] |
      v($_1$,...,e$_n$) | let p = e$_1$ in e$_2$ | zip(e$_1$,...,e$_n$) | 
      unzip(e) | iota(e) | replicate(e$_n$, e$_v$) | size(e) |
      reshape((e$_1$,...,e$_n$),e) | transpose(e) | split(e$_1$,e$_2$) |
      concat(e$_1$,e$_2$) | 
      let v$_1$ = v$_2$ with [e$_1$,...,e$_n$] <- e$_v$ in e$_b$  |
      loop (p = e$_1$) = for v < e$_2$ do e$_3$ in e$_4$
\end{lstlisting}


The Futhark language support anonymous functions, but it is not possible to curry functions in the Futhark language,
so the anonymous function can only take one argument.
If the function needs more than one argument it needs to be given as a tuple.
Except for inline anonymous functions all functions are defined globally \cite{TroelsHenriksen}. \\

Futhark is mostly a first order language but supports bulk (parallel) operations on arrays
using the built-in second-order array combinators (SOACs) of the language. 

Some of the build-in fuctions in the Futhark language not explixitly mentioned in the definition above 
 is the second-order array combinators: 
{\tt map}, {\tt filter}, {\tt reduce} and {\tt scan}.
The operators have the expected functionality also found in Haskell and Standard ML,
that is {\tt map} takes a function and an array and apply the function on the array.
If the array is multi-dimensional the function is applied to the outer most dimension.
The function {\tt reduce} takes as arguments a function, a neutral element and an array.
Like the {\tt map} function, the {\tt reduce} function takes the function it is given in the arguments
and apply it on the outer-most dimension of the array \cite{TroelsHenriksen}. 
% soacs tager l(kernel) som kan defineres på forskellige måder og som kan curryes
The build-in SOACs can take a function as an argument. This function or kernel can be defined in 
different ways. One of them is a lambda that unlike the normal lamdas can be curried. It can also be either a function 
referenced with an indentifyer (id) or another build-in operator (op).

\begin{lstlisting}[numbers=none,frame=none]
l ::=  fn t (t$_1$ v$_1$,..., t$_n$ v$_n$) => e
    |  id (e$_1$,...,e$_n$)
    |  op $\odot$ (e$_1$,..., e$_n$)
\end{lstlisting}


Another function is the function {\tt size} that takes an array as an argument. It returns the array length i.e. the number of elements if the array given is one fimentional or the dimentions of the array if it is multidimentional. \\

% funktioner skla definere returtype og type på alle argumenter
The general form of a Futhark function is the keyword fun followed by a return type all arguments 
with their typed defined in a list in parentheses.
\begin{lstlisting}[numbers=none,frame=none]
fun ::=  fun t v(t$_1$ v$_1$,...t$_n$ v$_n$) = e
\end{lstlisting}


The Futhark language supports multidimensional arrays in the form of nesting of array types,
i.e. an int array array will contain int arrays and so on.
The general type in the Futhark language consist of four base types: {\tt int}, {\tt floa}, {\tt real} and {\tt bool} and tupels \{t$_1$,...,t$_n$\}, arrays [t] and unique arrays *[t].\\

Futhark uses 0-indexing for indexing into arrays.\\ %In Futhark indexing are done with 0-indexing

% indbyggede functioner som vi bruger og som faktisk er polymorfiske men de kan ikke types i futhark da futharks typesystem ikke kan udtrykke polymorphi.
In general the Futhark language does not support polymorphism in functions,
the only exception is the built-in second-order array combinators that work on arrays of any base type. 
However this polymorphism can not be expressed in Futharks own type system. 




%The basic types in Futhark is {\tt int}, {\tt char}, {\tt bool}, {\tt real} and regular arrays.
%The type system of Futhark does not support polymorphism,
%however the build-in SOACs work on all regular arrays created of the basic types. 

%Does not support polymorfism in types

\section{Testing}
We have applied two types of testing in our project. One if a form of correctness test set op as an automated test
framework, the other is to test the efficiency of the generated test in form of benchmarks. 

\subsection{Automated testframework}
In order to test the correctness of the the generated code we have set up a test using the Cabal framework to make automatet tests that take the TAIL code though the tail2futhark compiler and the Futhark compiler and compair the result from the Futhark compiler with a premade result file containing the correct result. The automated test made it possible to run all tests whenever we did an alteration to the compiler. 
Running the tests every time we made an alteration enabled us to check if the new alteration had created a problem with the work we had allredy done. \\

We have the tests in a directory called {\tt test/ourtests} in the {\tt tail2futhark} project. \\

%We have not done thorough testing on all the fuctions implemented in the compiler as that is a very time consuming task. 
To test that our implementation of the TAIL functions work correctly we have created test to see if the function:
\begin{itemize}
\item works on different data types
\item work on edgecases
\item works on positive and negative input
\item function correct in all branches in if-then-else expressions
\end{itemize}
In order to thoroughly test the compiler all functions should be have specific test that test one of each of the above things
that meaningfully apply to the function. \\

We have not testet for or taken into account the possibility of TAIL code that are incorrect as it is generated by a compiler and only used as an intermidiate language. 

Because of the importance of the multidimentional arrays for the language we have testet each function on input of 1 dimention and input of at least 2 dimentions. 

\subsection{Benchmarks}
We have used benchmarks to mesure preformance of the generated Futhark code by comparing it with the TAIL code.
Because no parallel backend are finished for either TAIL or Futhark we use a sequential backend for both languages. \\

We have used the 


One of the benchmarks we used was matrix multiplication. The code in TAIL can be seen below. 

\begin{lstlisting}
let v0:[int]2 = reshape{[int],[1,2]}([3,2],iotaV(5)) in
let v1:[int]2 = transp{[int],[2]}(v0) in
let v6:[int]3 = transp2{[int],[3]}([2,1,3],
                     reshape{[int],[2,3]}([3,3,2],v0)) in
let v12:[int]3 = transp2{[int],[3]}([1,3,2],
                     reshape{[int],[2,3]}([3,2,3],v1)) in
let v17:[int]2 = reduce{[int],[2]}(addi,0,
                zipWith{[int,int,int],[3]}(muli,v6,v12)) in
let v22:[int]0 = reduce{[int],[0]}(muli,1,
                 reduce{[int],[1]}(addi,0,v17)) in
i2d(v22)
\end{lstlisting}

It becomes the following Futhark code when run through the compiler.

\bibliography{references}{} 
\bibliographystyle{plain}

\end{document}
