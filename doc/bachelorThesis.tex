\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}
\usepackage{cite}
\usepackage{stmaryrd}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{tabu}

\lstset{
  mathescape,
  moredelim=[is][\underbar]{_}{_}
}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn \& Henriks Urms}\\
  \\ \textit{Supervisor:} Martin Elsman
  % \texttt{a.kiehn89@gmail.com} \\
  %\\ \texttt{a.kiehn89@gmail.com} \\ \\
  %\Large{Henriks Urms}
  %\\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{5cm}
  \Huge{Bachelor's thesis} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}
%\renewcommand{\arraystretch}{1.2}

\newcommand{\evals}[1]{\llbracket #1 \rrbracket}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/natbio-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/natbio-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/nat-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\abstract

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  REPORT STARTS HERE  %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The intermidiate language TAIL}

The semantics of the type system of TAIL can be seen below. The types are devided into base types ($\kappa$), shape types ($\rho$), types ($\tau$), and type schemes ($\sigma$).The letter $i$ denotes an integer scalar value and the letter $\alpha$, and the letter $\gamma$ denotes type variables and shape variables respectively.
\begin{lstlisting}[numbers=none,frame=none]
$\kappa$ ::= int | double | bool | $\alpha$
$\rho$ ::=  $i$ | $\gamma$ | $\rho$ $+$ $\rho$'
$\tau$ ::= $[\kappa]^{\rho}$ | $\langle \kappa \rangle^\rho$ | S$_{\kappa}$($\rho$) | SV$_{\kappa}$($\rho$) | $\tau \rightarrow \tau$'
$\sigma$ ::= $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$
\end{lstlisting}
The type system of TAIL supports array types ($[\kappa]^{\rho}$) that keeps track of the shape of an array in its type.
The integer scalar in the arrays shape denotes the rank of the array and must be a non-negative integer. 
It also supports vector types ($\langle \kappa \rangle^\rho$), this type is used specificly for vectors of a specific length. For example {\tt <int>8} denotes a vector of ints of known length 8. If the vectors length is not staticly known it is instead expressed as an array of rank 1. 
In addition the types system also supports singleton integers, doubles, and booleans (S$_{\kappa}$($\rho$)), single-element integer, double, and boolean vectors (SV$_{\kappa}$($\rho$) and funtion types ($\tau \rightarrow \tau$'). \\

%The types schemes ($\sigma$) are expressed through substitution...
The type system make use of substitution in order to express type schemes ($\sigma$). Type substitusion ($S_t$) that maps type variables to base types and shape substitusion ($S_s$) that maps shape variables to shape types. A general substitution ($S$) is a pair ($S_t$,$S_s$) of type substitution and shape substitution. Using the substitution $S$ on an object $B$ means apllying 
both $S_t$ and $S_s$ on objects in $B$. A type $\tau$' is an instance of a type scheme $\sigma$ = $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$ (written $\sigma$= $\tau$') if a substitustion $S$ exists such that $S(\tau)$ = $\tau$'. \\

The syntax of operators and expressions is given bellow. The letter $v$ is used to denote values and the letter $x$ is used to dentote program variables. 
\begin{lstlisting}[numbers=none,frame=none]
op ::= addi | subi | multi | mini | maxi | addd | subd | 
       muld | mind | maxd | andb | orb | xorb |  nanb | 
       norb | notb | lti | ltei | gti | gtei | eqi | neqi |
       ltd | lted | gtd | gted | eqd | neqd | iota | each |
       reduce | i2d | b2i | reshape0 | reshape | rotate |
       transp | transp2 | zipWith | shape | take | drop |
       first | cat | cons | snoc | shapeV | catV | consV | 
       snocV | iotaV | rotateV | takeV | dropV | firstV 
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
e ::= $v$ | $x$ | $[\overrightarrow{e}]$ | $e$ $e'$ | let $x$ = $e_1$ in $e_2$ | $op(\overrightarrow{e})$
\end{lstlisting}
A TAIL programs always consist of a single expression. An expression can then be a value, variable, 
list of expressions, a let expression or an operator. Each TAIL operator have a unique type scheme. \\

One of the operators with a simple type scheme is the binary operator maxi that take two arguments $a$ and $b$ resturns the argument with the highest value. Its type scheme are as follows:
\begin{lstlisting}[numbers=none,frame=none]
maxi : int $\rightarrow$ int $\rightarrow$ int
\end{lstlisting}

Other operators have more complex type schemes. Examples of thouse are the parallel operators. 
There are four parallel operators in TAIL, {\tt each}, {\tt eachV}, {\tt reduce} and {\tt zipWith}.
The functions {\tt each} and {\tt eachV} are known in many languages as map.
The type scheme for the function {\tt each} is:
\begin{lstlisting}[numbers=none,frame=none]
each : $\forall\alpha\beta\gamma.(\alpha \rightarrow \beta)\rightarrow [\alpha]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
The function takes two arguments: a function $f$ and an array $a$ and returns an array where $f$ is applied to each element of $a$ i.e. $[f(a_1),..,f(a_n)]$.
If the rank of the array is greater than 1 the {\tt each} function work as a map on the fattened representation of the array,
that is, the function is applied on the inner most dimension of the array.

The {\tt eachV} function is a special case of {\tt each} and is used on the special vector type.\\

The function {\tt reduce} works similar to fold known from functional languages. The type scheme for {\tt reduce} is:
\begin{lstlisting}[numbers=none,frame=none]
reduce : $\forall\alpha\gamma.(\alpha \rightarrow \alpha \rightarrow \alpha)\rightarrow \alpha \rightarrow [\alpha]^{1 +\gamma} \rightarrow [\alpha]^{\gamma}$
\end{lstlisting}
The function takes as arguments a associative binary operator $op$ for instance $+$, a neutral element $n$, for instance 0 and array $a$.
It returns a value made from applying $+$  to first the netral element and the first element in $a$ and then to the result of the previus calculation and the next element in the array e.g. 0 $+$ $a_1$ $+$ ... $+$ $a_n$.
The {\tt reduce} function reduce an array of rank $\gamma+1$ to an array of rank $\gamma$ by reducing along the inner-most dimension.
The difference to {\tt fold} is that the operator has to be associative and the start element has to be neutral
because the execution is parallel.\\

The {\tt zipWith} function's type scheme is given as follows: 
\begin{lstlisting}[numbers=none,frame=none]
zipWith  : $\forall\alpha_{1}\alpha_{2}\beta\gamma.(\alpha_1 \rightarrow \alpha_2 \rightarrow \beta)\rightarrow [\alpha_1]^{\gamma} \rightarrow [\alpha_2]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
The functon takes as arguments a function $f$ that works on a pair $(x,y)$ and two arrays $a_1$ and $a_2$. It returns an array where the n'th element are $f$ applied to the pair $({a_{1}}_n,{a_{2}}_n)$ 
Like the other tree operators it works on the inner-most dimension of the array\cite{ElsmanDybdal:Array:2014}.\\

The background for designing TAIL was to create a typed intermediate language for the array programming language APL. TAIL is still under development and so is the {\tt apltail} compiler which compiles a subset of APL into TAIL \cite{ElsmanDybdal:Array:2014}.
APL is an older language created in the 1960's by Kenneth E. Iverson.
APL is an array programming language, its main type is the multi-dimensional array 
and most of the built-in functions in the language are array operators that work on this type. 
Most of its built-in functions or operators are represented by unicode symbols allowing for very concise code.
The APL language is dynamically typed. It supports first and second order functions and these functions work on arrays of any type. 
Even though it is an old language it is still used in the financial world 
where large code bases are still operational and actively developed \cite{ElsmanDybdal:Array:2014}. \\

TAIL was designed with the purpose of targeting parallel architectures such as GPUs and allows parallel programs to be
expressed in a highly abstract manner.
The TAIL compiler can also efficiently compile TAIL code into sequential code in a C-like language.
The subset of APL operators that TAIL support are shown earlier in this section.

The TAIL compiler infers types for the values in the APL program and can annotate bindings with
instance declarations. An instance declaration provides the base type and rank of the array. Or in
the case of vectors the size of the vector.

The language TAIL is statically typed and suports polymorphism. 
Most of the operators in TAIL are very general i.e. they are polymorphic with respect to array ranks and base types.
Although for some operations a specific type is needed.
An example is the {\tt take} function. It takes as argument a number (of type int) and an array of type $\alpha^\gamma$.\\

 TAILs type system takes the parallelism of APL and transforms it to a more manageable form adding explicit type
 information to the constructs.
Another benefit of the expressiveness of TAILs type system is that it allows the (TAIL) compiler to express some operators which
are primitive in APL using simpler operators, one such operator is that of the inner product \cite{ElsmanDybdal:Array:2014}. \\

The aplacc parser for TAIL represents the TAIL expressions in the abstract syntax tree as variables, constants, infinity, the negative representation of 
the expression, let expressions, operators and lambda expressions. 

TAIL does not support curried functions but require functions to be fully applied.FORKERT?!?!?!?!\\

% In APL indexing are done with 1-indexing but it is possible to change the indexing to 0-indexing on the fly. 

%In TAIL the array type is a pair of a base type and a rank. The rank is a non-negative integer.
%The base type of an array is the type of the elements in the array and is one of the types
%: {\tt int}, {\tt double}, {\tt bool} {\tt char}. 
%Scalars are a special case of arrays and is considered an array of rank 0.
%Arrays of rank 1 are also called vectors and there is a separate type for vectors for which the size is known at compile time.
%This vector type is a pair of the base type and the length of the vector. The vector type is a subtype of arrays of rank 1 and
%the compiler may decide to replace the type for it's supertype when appropriate.


 %\cite{TorbenMogensen}. \\



%%If we do not show the type schemes here we should reference to where they can be found in the article!!!!!!!!!!

%The types in TAIL are divided into four types. Firstly there are base types consisting of {\tt int}, {\tt double}, {\tt bool} and the polymorphic type {\tt $\alpha$} that can represent any one of them. Secondly, there are shape types that can be either a scalar value/variable of type int,  or a shape variable or a combination of two shape variables. \\
%Then there is array types that consist of a base type and a rank. Finally there is 


%The main datatype in TAIL is also a multidimensional array. Array types are in TAIL annotated with their ranks explicitly. 
%TAILs type system treats scalar values as special cases of the array time namely an array with rank 0. 

%There are two separate representations of vectors, either the special vector type used when the length of the vector is known or the general array type where the rank is 1.  
 
%Besides array and vector types, TAIL also have base types in the form of {\tt int}, {\tt double}, {\tt bool} and {\tt $\alpha$}.

%So far TAIL only support a subset of the APL functions and operators. 


% THIS IS HOW THE COMPILER IMPLEMENTS EXPRESSIONS
%\begin{lstlisting}[numbers=none,frame=none]
%e ::= x | i | d | c | inf | -e | let x:$t$ = e$_1$ in e$_2$ |
%      op[e$_1$,...,e$_n$] | fn x:$t$ e | [e$_1$,...,e$_n$]
%\end{lstlisting}

%The 'V' following some of the operators indicate they are a special version of the operator that works on vectors. \\
%The $t$'s are types that are part of the expression. \\

\newpage

\section{The functional language Futhark}

Futhark is a functional programming language inspired by Haskell and Standard ML.
It was designed to be an attractive choice for expressing complex parallel programs by having enough expressive power without
losing the possibility to do aggressive optimization and managing parallelism.
This is a challenge because higher the expressive power means optimizations become more difficult. 
Due to the focus on optimization the Futhark language only supports regular arrays
(arrays where all inner dimensions are of the same length),
this is because the support of non-regular arrays  complicates sizes analysis.
However Futhark does support nested parallelism as this is a feature many programs 
depend upon even though it does make optimization more difficult \cite{TroelsHenriksen}.
Indentation has no syntactical importance in the Futhark language. \\

%%something more about specific optimization????????????????\\

% funktioner bliver inlinet

A Futhark program consist of a list of function declarations of the form:
\begin{lstlisting}[numbers=none,frame=none]
fun return-type name(params...) = body
\end{lstlisting}
The body of the Futhark function then consist of an expression. 

The Futhark expressions can be found in the scheme below. They are among other constants, variables, binary- and other build-in operators and let expressions.

\begin{lstlisting}[numbers=none,frame=none]
e ::= k | v | {e$_1$,...,e$_n$} | [e$_1$,...,e$_n$] | e$_1$ $\odot$ e$_2$ |
      -e | not e | if e$_1$ then e$_2$ else e$_3$ | v[e$_1$,...,e$_n$] |
      v($_1$,...,e$_n$) | let p = e$_1$ in e$_2$ | zip(e$_1$,...,e$_n$) | 
      unzip(e) | iota(e) | replicate(e$_n$, e$_v$) | size(e) |
      reshape((e$_1$,...,e$_n$),e) | transpose(e) | split(e$_1$,e$_2$) |
      concat(e$_1$,e$_2$) | 
      let v$_1$ = v$_2$ with [e$_1$,...,e$_n$] <- e$_v$ in e$_b$  |
      loop (p = e$_1$) = for v < e$_2$ do e$_3$ in e$_4$
\end{lstlisting}


The Futhark language supports the declaration of functions, but it is not possible to curry functions in the Futhark language,
all functions applications have to be fully saturated. Furthermore it is only possible to declare monomorphic functions.
All functions are defined globally \cite{TroelsHenriksen}. \\

Futhark is mostly a first order language but supports bulk (parallel) operations on arrays
using the built-in second-order array combinators (SOACs) of the language. 

The second order array combinators have not been presented yet, they are:
{\tt map}, {\tt filter}, {\tt reduce} and {\tt scan}.
The operators have the expected functionality also found in Haskell and Standard ML,
that is {\tt map} takes a function and an array and apply the function on the array.
If the array is multi-dimensional the function is applied to the outer most dimension.
The function {\tt reduce} takes as arguments a function, a neutral element and an array.
Like the {\tt map} function, the {\tt reduce} function takes the function it is given in the arguments
and apply it on the outer-most dimension of the array \cite{TroelsHenriksen}. 
% soacs tager l(kernel) som kan defineres på forskellige måder og som kan curryes

The SOACs take functions as arguments, any built-in or user defined function can be used. For use with
SOACs it is also possible to use operators, partially applied functions and operators and lambda expressions.

The different syntactical constructs can be seen below:

\begin{lstlisting}[numbers=none,frame=none]
l ::=  fn t (t$_1$ v$_1$,..., t$_n$ v$_n$) => e
    |  id (e$_1$,...,e$_n$)
    |  op $\odot$ (e$_1$,..., e$_n$)
\end{lstlisting}


A built-in function that bears mentioning is {\tt size}.
It takes an array as an argument and returns the array length i.e.
the number of elements if the array given is one-dimensional or the dimensions of the array if it is multi-dimensional. \\

% funktioner skla definere returtype og type på alle argumenter
The general form of a Futhark function is the keyword fun followed by a return type all arguments 
with their typed defined in a list in parentheses.
\begin{lstlisting}[numbers=none,frame=none]
fun ::=  fun t v(t$_1$ v$_1$,...t$_n$ v$_n$) = e
\end{lstlisting}


The Futhark language supports multidimensional arrays in the form of nesting of array types,
i.e. an int array array will contain int arrays and so on.
The general type in the Futhark language consist of four base types: {\tt int}, {\tt float}, {\tt real} and {\tt bool} and tuples \{t$_1$,...,t$_n$\}, arrays [t] and unique arrays *[t].\\

Futhark uses 0-indexing for indexing into arrays.\\ %In Futhark indexing are done with 0-indexing

% indbyggede functioner som vi bruger og som faktisk er polymorfiske men de kan ikke types i futhark da futharks typesystem ikke kan udtrykke polymorphi.
%In general the Futhark language does not support polymorphism in functions,
%the only exception is the built-in second-order array combinators that work on arrays of any base type. 
%However this polymorphism can not be expressed in Futharks own type system.


%The basic types in Futhark is {\tt int}, {\tt char}, {\tt bool}, {\tt real} and regular arrays.
%The type system of Futhark does not support polymorphism,
%however the build-in SOACs work on all regular arrays created of the basic types. 

%Does not support polymorfism in types

\section{Testing}
We have applied two types of testing in our project. One if a form of correctness test set op as an automated test
framework, the other is to test the efficiency of the generated test in form of benchmarks. 

\subsection{Automated testframework}
In order to test the correctness of the the generated code we have set up a test using the Cabal framework to make automatet tests that take the TAIL code though the tail2futhark compiler and the Futhark compiler and compair the result from the Futhark compiler with a premade result file containing the correct result. The automated test made it possible to run all tests whenever we did an alteration to the compiler. 
Running the tests every time we made an alteration enabled us to check if the new alteration had created a problem with the work we had allredy done. \\

We have the tests in a directory called {\tt test/ourtests} in the {\tt tail2futhark} project. \\

%We have not done thorough testing on all the fuctions implemented in the compiler as that is a very time consuming task. 
To test that our implementation of the TAIL functions work correctly we have created test to see if the function:
\begin{itemize}
\item works on different data types
\item work on edgecases
\item works on positive and negative input
\item function correct in all branches in if-then-else expressions
\end{itemize}
In order to thoroughly test the compiler all functions should be have specific test that test one of each of the above things
that meaningfully apply to the function. \\

We have not testet for or taken into account the possibility of TAIL code that are incorrect as it is generated by a compiler and only used as an intermidiate language. 

Because of the importance of the multidimentional arrays for the language we have testet each function on input of 1 dimention and input of at least 2 dimentions. 

\subsection{Benchmarks}
We have used benchmarks to mesure preformance of the generated Futhark code by comparing it with the TAIL code.
Because no parallel backend are finished for either TAIL or Futhark we use a sequential backend for both languages. \\

We have used the 


One of the benchmarks we used was matrix multiplication. The code in TAIL can be seen below. 

\begin{lstlisting}
let v0:[int]2 = reshape{[int],[1,2]}([3,2],iotaV(5)) in
let v1:[int]2 = transp{[int],[2]}(v0) in
let v6:[int]3 = transp2{[int],[3]}([2,1,3],
                     reshape{[int],[2,3]}([3,3,2],v0)) in
let v12:[int]3 = transp2{[int],[3]}([1,3,2],
                     reshape{[int],[2,3]}([3,2,3],v1)) in
let v17:[int]2 = reduce{[int],[2]}(addi,0,
                zipWith{[int,int,int],[3]}(muli,v6,v12)) in
let v22:[int]0 = reduce{[int],[0]}(muli,1,
                 reduce{[int],[1]}(addi,0,v17)) in
i2d(v22)
\end{lstlisting}

It becomes the following Futhark code when run through the compiler.

\bibliography{references}{} 
\bibliographystyle{plain}

\end{document}
