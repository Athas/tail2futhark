\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}
\usepackage{cite}
\usepackage{stmaryrd}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{tabu}

\lstset{
  mathescape,
  moredelim=[is][\underbar]{_}{_}
}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn \& Henriks Urms}\\
  \\ \textit{Supervisor:} Martin Elsman
  % \texttt{a.kiehn89@gmail.com} \\
  %\\ \texttt{a.kiehn89@gmail.com} \\ \\
  %\Large{Henriks Urms}
  %\\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{5cm}
  \Huge{Bachelor's thesis} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}
%\renewcommand{\arraystretch}{1.2}

\newcommand{\evals}[1]{\llbracket #1 \rrbracket}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/natbio-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/natbio-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/nat-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\abstract

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  REPORT STARTS HERE  %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The intermidiate language TAIL}

The syntax of the types in TAIL can be seen below. The types are devided into base types ($\kappa$), shape types ($\rho$), types ($\tau$), and type schemes ($\sigma$).The letter $i$ denotes an integer scalar value and the letter $\alpha$, and the letter $\gamma$ denotes type variables and shape variables respectively.
\begin{lstlisting}[numbers=none,frame=none]
$\kappa$ ::= int | double | bool | $\alpha$
$\rho$ ::=  $i$ | $\gamma$ | $\rho$ $+$ $\rho$'
$\tau$ ::= $[\kappa]^{\rho}$ | $\langle \kappa \rangle^\rho$ | S$_{\kappa}$($\rho$) | SV$_{\kappa}$($\rho$) | $\tau \rightarrow \tau$'
$\sigma$ ::= $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$
\end{lstlisting}
The type system of TAIL supports array types ($[\kappa]^{\rho}$) that keeps track of the shape of an array in its type.
The integer scalar in the arrays shape denotes the rank of the array and must be a non-negative integer.
The type system also supports vector types ($\langle \kappa \rangle^\rho$), this type is used specificly for vectors of a specific length. For example {\tt <int>8} denotes a vector of ints of known length 8. If the vectors length is not staticly known it can be instead expressed as an array of rank 1.
Scalar values that are statically known have a seperate type (S$_{\kappa}$($\rho$)), i.e. integers, doubles, and booleans, their value is contained in the type.
In addition there also exists single-element integer, double, and boolean vector types (SV$_{\kappa}$($\rho$) for arrays where the element is statically known.
Finally there exists function types ($\tau \rightarrow \tau$'). \\

%The types schemes ($\sigma$) are expressed through substitution...
The type system makes use of substitution in order to express type schemes ($\sigma$). Type substitusion ($S_t$) that maps type variables to base types and shape substitusion ($S_s$) that maps shape variables to shape types. A general substitution ($S$) is a pair ($S_t$,$S_s$) of type substitution and shape substitution. Using the substitution $S$ on an object $B$ means apllying 
both $S_t$ and $S_s$ on objects in $B$. A type $\tau$' is an instance of a type scheme $\sigma$ = $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$ (written $\sigma$= $\tau$') if a substitustion $S$ exists such that $S(\tau)$ = $\tau$'. \\

The syntax of operators and expressions is given bellow. The letter $v$ is used to denote values and the letter $x$ is used to dentote program variables. 
\begin{lstlisting}[numbers=none,frame=none]
op ::= addi | subi | multi | mini | maxi | addd | subd | 
       muld | mind | maxd | andb | orb | xorb |  nanb | 
       norb | notb | lti | ltei | gti | gtei | eqi | neqi |
       ltd | lted | gtd | gted | eqd | neqd | iota | each |
       reduce | i2d | b2i | reshape0 | reshape | rotate |
       transp | transp2 | zipWith | shape | take | drop |
       first | cat | cons | snoc | shapeV | catV | consV | 
       snocV | iotaV | rotateV | takeV | dropV | firstV 
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
e ::= $v$ | $x$ | $[\overrightarrow{e}]$ | $e$ $e'$ | let $x$ = $e_1$ in $e_2$ | $op(\overrightarrow{e})$
\end{lstlisting}
A TAIL program always consists of a single expression. An expression can then be a value, variable, 
list of expressions, a let expression or an operator. Each TAIL operator has a unique type scheme. \\

One of the operators with a simple type scheme is the binary operator maxi that take two arguments $a$ and $b$ evaluates to the argument with the highest value. Its type scheme are as follows:
\begin{lstlisting}[numbers=none,frame=none]
maxi : int $\rightarrow$ int $\rightarrow$ int
\end{lstlisting}

Other operators have more complex type schemes. Examples of those are the parallel operators. 
There are four parallel operators in TAIL, {\tt each}, {\tt eachV}, {\tt reduce} and {\tt zipWith}.
The functions {\tt each} and {\tt eachV} are known in many languages as map.
The type scheme for the function {\tt each} is:
\begin{lstlisting}[numbers=none,frame=none]
each : $\forall\alpha\beta\gamma.(\alpha \rightarrow \beta)\rightarrow [\alpha]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
Given a function $f$ and an array $a$ {\tt each f a } evaluates to an array where $f$ is applied to each element of $a$ i.e. $[f(a_1),..,f(a_n)]$.
If the rank of the array is greater than 1 the {\tt each} function works as a map on the fattened representation of the array,
that is, the function is applied on the inner most dimension of the array, or seen in another way, on each basic value.

The {\tt eachV} function is a special case of {\tt each} and is used on vector types.\\

The function {\tt reduce} works similar to fold known from functional languages. The type scheme for {\tt reduce} is:
\begin{lstlisting}[numbers=none,frame=none]
reduce : $\forall\alpha\gamma.(\alpha \rightarrow \alpha \rightarrow \alpha)\rightarrow \alpha \rightarrow [\alpha]^{1 +\gamma} \rightarrow [\alpha]^{\gamma}$
\end{lstlisting}
The function takes as arguments a associative binary operator $op$ (for instance $+$), a neutral element $n$, (for instance 0) and array $a$.
The function application evaluates to the combination of the elements by the operator.
%It returns a value made from applying $+$  to first the netral element and the first element in $a$ and then to the result of the previus calculation and the next element in the array e.g. 0 $+$ $a_1$ $+$ ... $+$ $a_n$.
An array of rank $\gamma+1$ is reduced to an array of rank $\gamma$ along the inner-most dimension.
Unlike {\tt fold}, reduce makes no guarantees as to the order of application of the operator, therefore the operator has to be associative and the element has to be neutral, this is of course necessary for parrallel execution.\\

The {\tt zipWith} function's type scheme is given as follows: 
\begin{lstlisting}[numbers=none,frame=none]
zipWith  : $\forall\alpha_{1}\alpha_{2}\beta\gamma.(\alpha_1 \rightarrow \alpha_2 \rightarrow \beta)\rightarrow [\alpha_1]^{\gamma} \rightarrow [\alpha_2]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
Given a function $f$ that works on a pair $(x,y)$ and two arrays $a_1$ and $a_2$, {\tt zipWith f a\_1 a\_2}  evaluates to an array where the n'th element is $f$ applied to the pair $({a_{1}}_n,{a_{2}}_n)$ 
Like the other three operators it works on the inner-most dimension of the array\cite{ElsmanDybdal:Array:2014}.\\

The background for designing TAIL was to create a typed intermediate language for the array programming language APL. TAIL is still under development and so is the {\tt apltail} compiler which compiles a subset of APL into TAIL \cite{ElsmanDybdal:Array:2014}.
APL is an older language created in the 1960's by Kenneth E. Iverson.
APL is an array programming language, its main type is the multi-dimensional array 
and most of the built-in functions in the language are array operators that work on this type. 
Most of its built-in functions or operators are represented by unicode symbols allowing for very concise code.
The APL language is dynamically typed. It supports first and second order functions and these functions work on arrays of any type. 
Even though it is an old language it is still used in the financial world 
where large code bases are still operational and actively developed \cite{ElsmanDybdal:Array:2014}. \\

TAIL was designed with the purpose of targeting parallel architectures such as GPUs and allows parallel programs to be
expressed in a highly abstract manner.
The TAIL compiler can also efficiently compile TAIL code into sequential code in a C-like language.
The subset of APL operators that TAIL support are shown earlier in this section.

The TAIL compiler infers types for the values in the APL program and can annotate bindings with
instance declarations. An instance declaration provides the base type and rank of the array. Or in
the case of vectors the size of the vector.

The language TAIL is statically typed and suports polymorphism. 
Most of the operators in TAIL are very general i.e. they are polymorphic with respect to array ranks and base types.
Although for some operations a specific type is needed.
An example is the {\tt take} function. It takes as argument a number (of type int) and an array of type $\alpha^\gamma$.\\

 TAILs type system takes the dynamicly types of APL and transforms it to a more manageable form adding explicit type
 information to the constructs.
Another benefit of the expressiveness of TAILs type system is that it allows the (TAIL) compiler to express some operators which
are primitive in APL using simpler operators, one such operator is that of the inner product \cite{ElsmanDybdal:Array:2014}. \\

The aplacc parser for TAIL represents the TAIL expressions in the abstract syntax tree as variables, constants, infinity, the negative representation of 
the expression, let expressions, operators and lambda expressions. 

TAIL does not support curried functions but require functions to be fully applied.

% In APL indexing are done with 1-indexing but it is possible to change the indexing to 0-indexing on the fly. 

%In TAIL the array type is a pair of a base type and a rank. The rank is a non-negative integer.
%The base type of an array is the type of the elements in the array and is one of the types
%: {\tt int}, {\tt double}, {\tt bool} {\tt char}. 
%Scalars are a special case of arrays and is considered an array of rank 0.
%Arrays of rank 1 are also called vectors and there is a separate type for vectors for which the size is known at compile time.
%This vector type is a pair of the base type and the length of the vector. The vector type is a subtype of arrays of rank 1 and
%the compiler may decide to replace the type for it's supertype when appropriate.


 %\cite{TorbenMogensen}. \\



%%If we do not show the type schemes here we should reference to where they can be found in the article!!!!!!!!!!

%The types in TAIL are divided into four types. Firstly there are base types consisting of {\tt int}, {\tt double}, {\tt bool} and the polymorphic type {\tt $\alpha$} that can represent any one of them. Secondly, there are shape types that can be either a scalar value/variable of type int,  or a shape variable or a combination of two shape variables. \\
%Then there is array types that consist of a base type and a rank. Finally there is 


%The main datatype in TAIL is also a multidimensional array. Array types are in TAIL annotated with their ranks explicitly. 
%TAILs type system treats scalar values as special cases of the array time namely an array with rank 0. 

%There are two separate representations of vectors, either the special vector type used when the length of the vector is known or the general array type where the rank is 1.  
 
%Besides array and vector types, TAIL also have base types in the form of {\tt int}, {\tt double}, {\tt bool} and {\tt $\alpha$}.

%So far TAIL only support a subset of the APL functions and operators. 


% THIS IS HOW THE COMPILER IMPLEMENTS EXPRESSIONS
%\begin{lstlisting}[numbers=none,frame=none]
%e ::= x | i | d | c | inf | -e | let x:$t$ = e$_1$ in e$_2$ |
%      op[e$_1$,...,e$_n$] | fn x:$t$ e | [e$_1$,...,e$_n$]
%\end{lstlisting}

%The 'V' following some of the operators indicate they are a special version of the operator that works on vectors. \\
%The $t$'s are types that are part of the expression. \\

\newpage

\section{The functional language Futhark}

The syntax of Futhark type system can be seen below. The types are devided into types ($t$), constants ($k$) and patterns ($p$). The letter $n$ is used to denote an integer, the letter x is used to denote a decimal number, the letter $b$  denotes a boolean, the letter $c$ denotes a char, and the letter $v$ denotes a value that can be any of the before mentioned. A name pattern are represented with $id$. 
\begin{lstlisting}[numbers=none,frame=none]
$t$ ::= int | real | bool | {$t_1$,...,$t_n$} | [t] | *[t]
$k$ ::= $n$ | $x$ | $b$ | $c$ | {$v_1$,...,$v_n$} | [v$_1$,...,$v_n$] 
$p$ ::= $id$ | {$p_1$,...,$p_n$}
\end{lstlisting}
The general type in the Futhark language consist of four base types: integers, floating points, booleans, tuples ({\tt \{t$_1$,...,t$_n$\}}), arrays ({\tt [t]}), and unique arrays ({\tt *[t]}).
Tuple types are written as a comma seperated list of types or values surrounded by braces. For example \{int,bool\} are 
an pair of integer and boolean value. 
Arrays types are denotes by the elements (base) type enclosed by brackets. The layer of brackets indicates the dimention of the array type. For instance {\tt [int]} is a one-dimentional array of integers, and {\tt [[[bool]]]} is a tree-dimentional 
array of booleans.  All arrays must be regular that is all rows of for instance a two-dimentional array must have the same numer of elements. \\

The Futhark language is statuclally typed but does not support type interference. Also the type system of Futhark are not 
able to express polymorphism. It is therefore not possible to make polymorphic functions in Futhark. The only polymorphism that exists in the language is the one implemented in the build-in operators. 
The syntax of Futhark expressions are defined as follows:
\begin{lstlisting}[numbers=none,frame=none]
$e$ ::= $k$ | $v$ | {$e_1,...,e_n$} | [$e_1,...,e_n$] | $e_1$ $\odot$ $e_2$ |
      $-e$ | not $e$ | if $e_1$ then $e_2$ else $e_3$ | $v$[$e_1,...,e_n$] |
      $v$($e_1,...,e_n$) | let $p$ = $e_1 in e_2$ | zip($e_1,...,e_n$) | 
      unzip($e$) | iota($e$) | replicate($e_n, e_v$) | size($e$) |
      reshape(($e_1,...,e_n$),e) | transpose($e$) | split($e_1,e_2$) |
      concat($e_1,e_2$) | 
      let $v_1$ = $v_2$ with [$e_1,...,e_n$] <- $e_v$ in $e_b$  |
      loop ($p$ = $e_1$) = for $v$ < $e_2$ do $e_3$ in $e_4$ | map($l$, $e$) |
      filter($l$, $e$) |  reduce($l$, $x$, $e$) | scan($l$, $x$, $e$)
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$l$ ::=  fn $t$ ($t_1$ $v_1,..., t_n$ $v_n$) => $e$
    | $id$ ($e_1,...,e_n$)
    | op $\odot$ ($e_1,..., e_n$)
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$fun$ ::=  fun t v(t$_1$ v$_1$,...t$_n$ v$_n$) = $e$
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$prog$ ::= $\epsilon$ | $fun$ $prog$
\end{lstlisting}

The Futhark language supports the declaration of functions, but it is not possible to curry functions in the Futhark language, all functions applications have to be fully saturated. Furthermore it is only possible to declare monomorphic functions. A Futhark program consist of a sequence of function definitions. \\
All functions are defined globally \cite{TroelsHenriksen} except for inline anonymus functions (denoted with $fn$ in the syntax definition). These inline anonymus functions only occur in the second-order array combinators (SOACs) of the
 language.

Futhark is a functional programming language inspired by Haskell and Standard ML, it is mostly a first order language but supports bulk (parallel) operations on arrays
using the built-in SOACs that are: {\tt map}, {\tt reduce}, {\tt filter}, and {\tt scan}.\\

The functionality of the SOACs are what can be found in other functional languages such as Haskell or ML. 
The operator {\tt map} is defined as follows: 
\begin{lstlisting}[numbers=none,frame=none]
map : ($\alpha$ $\rightarrow$ $\beta$) $\rightarrow$ $[\alpha]$ $\rightarrow$ $[\beta]$
\end{lstlisting}
The type of the operator {\tt map($l$,$a$)} takes a function $l$ and an array $a$ and returns the array consisting of $l$ applied to each element of $a$.
If the array is multi-dimensional the function is applied to the outer most dimension. Meaning that if the function $l$ is 
maped into a two dimentionsl array the function would be aplied to an array not the elements of the array. For instance 
Note that the type of map is not expressed using Futharks own type system as there are no way of expressing polymophism with the laguages type system. \\

The type of the operator {\tt reduce} is defined as follows: 
\begin{lstlisting}[numbers=none,frame=none]
reduce : ($\alpha$ $\rightarrow$ $\alpha$ $\rightarrow$ $\alpha$) $\rightarrow$ $\alpha$ $\rightarrow$ $[\alpha]$ $\rightarrow$ $\alpha$
\end{lstlisting}
The operator takes as arguments a function $l$, a neutral element $x$ and an array $a$.
It returns the result of aplying the function $l$ for instance *, on the result of the previus calculation and the next element of the array starting with the result sat to be the neutral element i.e. $x*a[0]*...*a[n]$
Like the {\tt map} function, the {\tt reduce} function takes the function it is given in the arguments
and apply it on the outer-most dimension of the array. \cite{TroelsHenriksen}. 
% soacs tager l(kernel) som kan defineres på forskellige måder og som kan curryes
The functions {\tt filter} and {\tt scan} also work on the outermost dimention on the array. The {\tt filter} operator
takes a function $l$ that returns a bolean value and an array $a$ and returns an array containing the elements of $a$
where $l(a)=true$. 
The operator {\tt scan} takes 
 

The SOACs take functions as arguments, any built-in or user defined function can be used. For use with
SOACs it is also possible to use operators, partially applied functions and operators and lambda expressions.\\

There are other build-in operators in Futhark besides the SOACs. The Futhark language support a number arithmetic 
binary operators ($e_1$ $\odot$ $e_2$) for instance +, -, integer division, and integer modulo. The language also 
support operators that work on arrays, for instance {\tt size} that takes an expression $e$ that can be eather one dimentional array (vector) or a multi-dimentional array and returns a comma seperated list containing the lenth of each dimention of $e$. If $e$ is a one-dimentional, the resurning list contains one element that is the length of the vector i.e. the number of elements. \\

The idea behind designing Futhark was to design a languge to be an attractive choice for expressing complex parallel programs by having enough expressive power without
losing the possibility to do aggressive optimization and managing parallelism.
This is a challenge because higher the expressive power means optimizations become more difficult. 
Due to the focus on optimization the Futhark language only supports regular arrays
(arrays where all inner dimensions are of the same length),
this is because the support of non-regular arrays  complicates sizes analysis.
However Futhark does support nested parallelism as this is a feature many programs 
depend upon even though it does make optimization more difficult \cite{TroelsHenriksen}.
Indentation has no syntactical importance in the Futhark language. \\


The Futhark language supports multidimensional arrays in the form of nesting of array types,
i.e. an int array array will contain int arrays and so on.


Futhark uses 0-indexing for indexing into arrays.\\ %In Futhark indexing are done with 0-indexing

%%something more about specific optimization????????????????\\

% funktioner bliver inlinet

% funktioner skla definere returtype og type på alle argumenter


% indbyggede functioner som vi bruger og som faktisk er polymorfiske men de kan ikke types i futhark da futharks typesystem ikke kan udtrykke polymorphi.
%In general the Futhark language does not support polymorphism in functions,
%the only exception is the built-in second-order array combinators that work on arrays of any base type. 
%However this polymorphism can not be expressed in Futharks own type system.

%Does not support polymorfism in types

\section{The compilation scheme}

There main contribution with this paper is the compilation scheme presented in this section. It shows a detailed compilation of a subset of TAIL's operators to Futhark code. 
The compilation scheme is implementation independent and done in a form of mathematical notation. 
In this section both the compilation scheme and the notation is described. \\

On the left hand side of the scheme is the TAIL functions, the right hand side contains the Futhark expression they are translated to. An expression wraped in double brackets i.e. $\evals{x}$ signifies the compilation of the TAIL expression $x$  \\

%%% Table
\begin{tabular}{l c l}% to \linewidth {l c X}
$\evals{x}$ & $=$ & $x$ \\
$\evals{i}$ & $=$ & $i$ \\
$\evals{d}$ & $=$ & $d$ \\
$\evals{c}$ & $=$ & $c$ \\
$\evals{-e}$ & $=$ & -$\evals{e}$ \\
$\evals{ \text{let } x:t = e_1 \text{ in } e_2} $ & $=$ & let $\evals{x} = \evals{e_1} \text{ in } \evals{e_2} $\\
$\evals{[e_1,...,e_n]}$ & $=$ & $ [ \evals{e_1},...,\evals{e_n}]$\\
$\evals{\text{op } [e_1,...,e_n]}$ & $=$ & $\evals{\text{op}}_{op} \evals{[e_1,...,e_n]}$\\

$\evals{\text{op} [e_1,...,e_n]}$ & $=$ & $\evals{\text{op}}_{fun} \; (\evals{e_1},...,\evals{e_n})$\\
$\evals{\text{op} [e_1,e_2]}$ & $=$ & $\evals{e_1} \; \evals{\text{op}}_{op} \; \evals{e_2}$\\

$\evals{\text{each}_{[t_1,t_2,r]}(f,a)}$ & $=$ & $
  \begin{cases}
    $map$(\evals{f}_{fn}^{\evals{t_2}},\evals{a}) & r=1\\
    $map (fn $t_2^r \; (t_1^r \; x)$ {\tt =>} $ \evals{\text{each}_{[t,r-1]}(f,x)},\evals{a}) & r > 1  \\
  \end{cases}$\\

$\evals{\text{eachV}_{[t_1,t_2,r]}(f,a)}$ & $=$ & map$(\evals{f}_{fn}^{\evals{t_2}},\evals{a}) $  \\         

$\evals{\text{vrotate}_{[t,r]}(i,a)}$ & $=$ & map(fn x {\tt =>} a[x + i {\tt \%} \text{size}(0,a)], iota(size(0,a)) \space\space , x = fresh\\
$\evals{\text{vreverse}_{[t,r]}(a)}$ & $=$ & map(fn x {\tt =>} a[\text{size}(0,a)-x-1], $\text{iota}(\text{size}(0,a))$ \space\space , x = fresh\\
$\evals{\text{reshape}_{[t,r_1,r]}(a_1,a_2)}$ & $=$ & reshape$(\evals{a_1},(\text{reshape1}_{\evals{t}}(
% \prod_{i=0}^{r_1} \text{size}(i,a_1)
\text{osize}%(\text{size}(0,a_1)*\ldots*\text{size}(r_1,a_1)
, \text{reshape}(
\text{isize}%\text{size}(0,a_2)*\ldots*\text{size}(r_2,a_2)
, \evals{a_2})))) $ \\
&& \hspace{4ex} where osize = $\text{size}(0,a_1)*\ldots*\text{size}(r_1,a_1)$ \\
&& \hspace{4ex} \phantom{where} isize = $ \text{size}(0,a_2)*\ldots*\text{size}(r_2,a_2) $ \\

$\evals{\text{reduce}_{[t,r]}(f,n,a)}$ & $=$ & $
  \begin{cases}
    \text{reduce}(\evals{f}_{fn}^{\evals{t}},\evals{n},\evals{a}) & r=1 \\
    $map (fn $ t^{r-1} \; (t^r \; x)$ {\tt =>} $ \evals{\text{reduce}_{[t,r-1]}(f,n,x)},\evals{a}) & r>1\\
  \end{cases}$\\

$\evals{\text{zipWith}_{[t_1,t_2,t_3,r]}(f,a_1,a_2)}$ & $=$ & \\
  \multicolumn{3}{r}{ $\begin{cases}
    $map$(\evals{f}_{fn}^{\evals{t_3}},$zip($\evals{a_1},\evals{a_2})) & r=1 \\
    $map(fn $t_3^{r-1} \; (t_1^{r-1} \; x, t_2^{r-1} \; y) $ {\tt =>} $
      \evals{\text{zipWith}_{[t_1,t_2,t_3r-1]}(f,x,y)} , $zip($ \evals{a_1}, \evals{a_2})) & r>1\\
  \end{cases}$ }\\

$\evals{\text{cat}_{[t,r]}(a_1,a_2)}$ & $=$ & $
  \begin{cases}
    \text{concat}(\evals{a_1},\evals{a_2}) & r=1 \\
    $map (fn $ \evals{t}^{r-1} \; (\evals{t} \; x, \evals{t} \; y)$ {\tt =>} $ \evals{\text{cat}_{[t,r-1]}(x,y)}, \text{zip}(\evals{a_1}, \evals{a_2}) & r>1\\
  \end{cases}$\\

$\evals{\text{first}_{[t,r]}(a)}$ & $=$ & let x = $\evals{a}$ in $x[\underbrace{0,...,0}_\text{r times}]$\\

$\evals{\text{firstV}_{[t,r]}(a)}$ & $=$ & $\evals{\text{first}_{t,1}(a)}$\\

$\evals{\text{take}(i,a)}$ & $=$ & reshape(oshape,\text{take1}$_{\evals{t}}$(osize,\text{reshape}(isize,$\evals{a})))$\\
&& \hspace{4ex} where oshape = ($|i|, \text{size}(1,\evals{a}),\cdots,$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} osize = ($i* \text{size}(1,\evals{a}) *\ldots*$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} isize = \text{size}(0,$\evals{a}$)$*\ldots*$\text{size}(r,$\evals{a}$)\\

$\evals{\text{takeV}_t(d,a)}$ & $=$ & $\text{take1}_{\evals{t}}(\evals{d},\evals{a})$\\

$\evals{\text{drop}(i,a)}$ & $=$ & \text{reshape}(\text{oshape}, $\text{drop1}_{\evals{t}}(\text{osize}, \text{reshape}(\text{isize},\evals{a}))$\\
&& \hspace{4ex} where oshape = (max(0,size(0,$\evals{a}$)-$|i|$),size(1,$\evals{a}$)$,\ldots,$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} osize = ($i *$size(1,$\evals{a}$)$ * \ldots*$size(r, $\evals{a}$))\\
&& \hspace{4ex} \phantom{where} isize = \text{size}(0,$\evals{a}$)$*\ldots*$\text{size}(r,$\evals{a}$)\\

$\evals{\text{dropV}_t(d,a)}$ & $=$ & $\text{drop1}_{\evals{t}}(\evals{d},\evals{a})$\\

$\evals{\text{transp}_{t,r}(a)}$ & $=$ & rearrange$((r-1,...,0),\evals{a})$\\

$\evals{\text{transp2}_{t,r}(a_1,a_2)}$ & $=$ & let $x$ = $\evals{a_1}$ in rearrange(($x[0]$-$1,\ldots,x[r$-$1]$-$1$),$\evals{a_2})$\\

%$\evals{\text{cons}_[t,r](e,a)}$ & $=$ &  
%  $\begin{cases}
%    \text{concat}([\evals{e}],\evals{a}) & r= 1\\
%    \text{map (fn }$$(x,y) $ {\tt =>} $ \evals{\text{cons}_{[t,r]}(x,y)}, \text{ zip}(\evals{e},\evals{a}))$$ & r > 1
%  \end{cases}$\\

$\evals{\text{cons}_[t,r](e,a)}$ & $=$ & rearrange$((r,\ldots,0), \text{concat(exp,arr)})$\\
&& \hspace{4ex} where exp = rearrange((r-1,\ldots,0),$\evals{e}$)\\
&& \hspace{4ex} \phantom{where} arr = rearrange((r-1,\ldots,0),$\evals{a}$)\\
  
$\evals{\text{snoc}_[t,r](a,e)}$ & $=$ & rearrange$((r,\ldots,0), \text{concat(arr,exp)})$\\
&& \hspace{4ex} where exp = rearrange((r-1,\ldots,0),$\evals{e}$)\\
&& \hspace{4ex} \phantom{where} arr = rearrange((r-1,\ldots,0),$\evals{a}$)\\
  
%$\evals{\text{snoc}_[t,r](a,e)}$ & $=$ & 
%  $\begin{cases}
%    \text{concat}([\evals{a}],\evals{e}) & r= 1\\
%    \text{map (fn }$$(x,y) $ {\tt =>} $ \evals{\text{snoc}_{[t,r]}(x,y)}, \text{ zip}(\evals{a},\evals{e}))$$ & r > 1
%  \end{cases}$\\

$\evals{\text{iota}(a)}$ & $=$ & map$(+ \; (1), \text{iota}(\evals{a})$\\

$\evals{\text{iotaV}(a)}$ & $=$ & $\evals{\text{iota}(a)}$\\

$\evals{\text{shape}_{t,r}(a)}$ & $=$ & $[\text{size}(0,\evals{a}),...,\text{size}(r-1,\evals{a})]$\\

$\evals{\text{shapeV}_{t,r}(a)}$ & $=$ & $[r]$\\
gi
\\
%\end{tabular}\\
%
%The compilation of fn are descirbed in a table of its own\\
%
%\begin{tabular}{l c l}
$\evals{ \text{fn } x:t $ {\tt =>} $ e}^{\tau}_{fn} $ & $=$ & $ \text{fn } \tau (\evals{t}\; x) $ {\tt =>} $ \evals{e}$\\
$\evals{ \text{fn } x:t_1$ {\tt =>} $\text{fn } y:t_2 $ {\tt =>} $ e}^{\tau}_{fn} $ & $=$ & $ \text{fn } \tau (\evals{t_1}\; x, \evals{t_2} \; y) $ {\tt =>} $ \evals{e}$\\
\end{tabular}\\

The gereral compilation of operators:\\

\begin{tabular}{l c l}
$\evals{addi}_{op}$ & $=$ & $+$\\
$\evals{i2d}_{fun}$ & $=$ & toReal\\ 
\end{tabular}\\

\section{Testing}
We have applied two types of testing in our project. One if a form of correctness test set op as an automated test
framework, the other is to test the efficiency of the generated test in form of benchmarks. 

\subsection{Automated testframework}
In order to test the correctness of the the generated code we have set up a test using the Cabal framework to make automatet tests that take the TAIL code though the tail2futhark compiler and the Futhark compiler and compair the result from the Futhark compiler with a premade result file containing the correct result. The automated test made it possible to run all tests whenever we did an alteration to the compiler. 
Running the tests every time we made an alteration enabled us to check if the new alteration had created a problem with the work we had allredy done. \\

We have the tests in a directory called {\tt test/ourtests} in the {\tt tail2futhark} project. \\

%We have not done thorough testing on all the fuctions implemented in the compiler as that is a very time consuming task. 
To test that our implementation of the TAIL functions work correctly we have created test to see if the function:
\begin{itemize}
\item works on different data types
\item work on edgecases
\item works on positive and negative input
\item function correct in all branches in if-then-else expressions
\end{itemize}
In order to thoroughly test the compiler all functions should be have specific test that test one of each of the above things
that meaningfully apply to the function. \\

We have not testet for or taken into account the possibility of TAIL code that are incorrect as it is generated by a compiler and only used as an intermidiate language. 

Because of the importance of the multidimentional arrays for the language we have testet each function on input of 1 dimention and input of at least 2 dimentions. 

\subsection{Benchmarks}
We have used benchmarks to mesure preformance of the generated Futhark code by comparing it with the TAIL code.
Because no parallel backend are finished for either TAIL or Futhark we use a sequential backend for both languages. \\

We have used the 


One of the benchmarks we used was matrix multiplication. The code in TAIL can be seen below. 

\begin{lstlisting}
let v0:[int]2 = reshape{[int],[1,2]}([3,2],iotaV(5)) in
let v1:[int]2 = transp{[int],[2]}(v0) in
let v6:[int]3 = transp2{[int],[3]}([2,1,3],
                     reshape{[int],[2,3]}([3,3,2],v0)) in
let v12:[int]3 = transp2{[int],[3]}([1,3,2],
                     reshape{[int],[2,3]}([3,2,3],v1)) in
let v17:[int]2 = reduce{[int],[2]}(addi,0,
                zipWith{[int,int,int],[3]}(muli,v6,v12)) in
let v22:[int]0 = reduce{[int],[0]}(muli,1,
                 reduce{[int],[1]}(addi,0,v17)) in
i2d(v22)
\end{lstlisting}

It becomes the following Futhark code when run through the compiler.

\bibliography{references}{} 
\bibliographystyle{plain}

\end{document}
