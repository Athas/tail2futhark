\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}
\usepackage{cite}
\usepackage{stmaryrd}
\usepackage{fixltx2e}
\usepackage{amsmath}
\usepackage{tabu}

\lstset{
  mathescape,
  moredelim=[is][\underbar]{_}{_}
}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn \& Henriks Urms}\\
  \\ \textit{Supervisor:} Martin Elsman
  % \texttt{a.kiehn89@gmail.com} \\
  %\\ \texttt{a.kiehn89@gmail.com} \\ \\
  %\Large{Henriks Urms}
  %\\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{5cm}
  \Huge{Bachelor's thesis} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}
%\renewcommand{\arraystretch}{1.2}

\newcommand{\evals}[1]{\llbracket #1 \rrbracket}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/natbio-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/natbio-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/nat-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\abstract

\newpage

\tableofcontents

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  REPORT STARTS HERE  %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
In recent years, there has been a lot of focus on leveraging the power of parallel hardware. 
One approach has been to design programming languages with explicit data-parallel constructs that can be compiled 
into highly parallel code. One such language is Futhark. The aim of Futhark is to target parallel hardware such as 
GPUs while itself being the target of more programmer-productivity oriented languages. The Futhark compiler 
performs several optimizations, such as fusion, which enhance the degree of 
parallelism \cite{T.Henriksen&C.Oancea}.\\

APL is an array language and includes various operations that are central to the language and are good candidates 
for parallel execution. Efforts in compiling APL to parallel backends already exist in the form of the language 
TAIL (Typed array intermediate language) and itâ€™s compiler \cite{ElsmanDybdal:Array:2014}.
The TAIL compiler captures the parallelism inherent in APL source code and brings it to a much more manageable form.
In our work we provide a compiler from TAIL 
to Futhark thus bridging the gap between APL and Futhark.\\

The language Futhark is designed to target parallel architectures and at the same time acting 
as an intermediate language for more feature-rich languages. By compiling APL to Futhark through TAIL the 
Futhark compiler can be used to generate parallel code from APL once a parallel backend for 
Futhark is completed.\\

There are traditionally five stages of a compiler if you compile a high level language to machine code: 
lexical analysis, syntax analysis, type checking, intermediate code generation, register allocation, machine 
code generation and assembly and linking \cite{TorbenMogensen}. However, in this project we are compiling from 
one high level language to another high level language. The structure does therefore look a little different. 
The first two phases are still lexical analysis and syntax analysis and are handled by a parser.
We made use of an already existing parser \cite{APLACC} and only modified it in order for it to work on the latest 
version of TAIL. The third phase is transforming the abstract syntax tree of TAIL to the abstract syntax tree 
representing the code in Futhark and the fourth phase is printing the AST so it becomes correct 
Futhark source code. \\

One of the main point of interest in the compilation between TAIL and Futhark is compiling the four array operators 
of TAIL: {\tt each}, {\tt eachV}, 
 {\tt reduce} and {\tt zipWith} to Futhark source code that include the four second-order array combinators in Futhark:  
 {\tt map}, {\tt filter}, {\tt reduce} and {\tt scan} \cite{ElsmanDybdal:Array:2014}\cite{TroelsHenriksen}. 
However as the functionality of these functions are not completely 
identical the work lies in creating a mapping that retains the parallelism in the original code in the target language.\\
This can be seen in the example below which illustrate this difference. The reduce function in the
TAIL language is mapped to a nested reduce function in the Futhark language.
As some function names exists in both languages the Futhark version of such occurrences are \underline{underlined}.

\begin{lstlisting}[numbers=none,frame=none]
reduce(+, [[1,2,3,4],[5,6,7,8]]))

  =>

_reduce_(fn x => map(+,x),[[1,2,3,4],[5,6,7,8,]])

\end{lstlisting}

This paper contributes with a compilation scheme that are implementation independent, showing a replicable 
way of how to translate the typed intermediate language of APL, TAIL, to the functional language Futhark. Also 
this paper presents an implementation of the previous mentioned scheme in Haskell. The efficiency of this
 implementation have been tested by comparing benchmarks test on code generated by the C-backend to TAIL 
 and the generated Futhark source code by using the C-backend to Futhark. \\

The project is open source and the source code can be found here:\\ https://github.com/henrikurms/tail2futhark.

Both Futhark and TAIL are ungoing research projects and are therefore subject to change bear in mind that the references cited are not up to date. For a up to date version of the languages and their compilers refer to their recepctive github repositories: \\

url\_tail 

url\_futhark

\section{The intermidiate language TAIL}

The syntax of the types in TAIL can be seen below. The types are divided into base types ($\kappa$), shape types ($\rho$), types ($\tau$), and type schemes ($\sigma$).The letter $i$ denotes an integer scalar value and the letter $\alpha$, and the letter $\gamma$ denotes type variables and shape variables respectively.
\begin{lstlisting}[numbers=none,frame=none]
$\kappa$ ::= int | double | bool | $\alpha$
$\rho$ ::=  $i$ | $\gamma$ | $\rho$ $+$ $\rho$'
$\tau$ ::= $[\kappa]^{\rho}$ | $\langle \kappa \rangle^\rho$ | S$_{\kappa}$($\rho$) | SV$_{\kappa}$($\rho$) | $\tau \rightarrow \tau$'
$\sigma$ ::= $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$
\end{lstlisting}
The type system of TAIL supports array types ($[\kappa]^{\rho}$) that keeps track of the shape of an array in its type.
The integer scalar in the arrays shape denotes the rank of the array and must be a non-negative integer.
The type system also supports vector types ($\langle \kappa \rangle^\rho$), this type is used specificly for vectors of a specific length. For example {\tt <int>8} denotes a vector of ints of known length 8. If the vectors length is not staticly known it can be instead expressed as an array of rank 1.
Scalar values that are statically known have a seperate type (S$_{\kappa}$($\rho$)), i.e. integers, doubles, and booleans, their value is contained in the type.
In addition there also exists single-element integer, double, and boolean vector types (SV$_{\kappa}$($\rho$) for arrays where the element is statically known.
Finally there exists function types ($\tau \rightarrow \tau$'). \\

%The types schemes ($\sigma$) are expressed through substitution...
The type system makes use of substitution in order to express type schemes ($\sigma$). Type substitusion ($S_t$) that maps type variables to base types and shape substitusion ($S_s$) that maps shape variables to shape types. A general substitution ($S$) is a pair ($S_t$,$S_s$) of type substitution and shape substitution. Using the substitution $S$ on an object $B$ means apllying 
both $S_t$ and $S_s$ on objects in $B$. A type $\tau$' is an instance of a type scheme $\sigma$ = $\forall\overrightarrow{\alpha}\overrightarrow{\gamma}$.$\tau$ (written $\sigma$= $\tau$') if a substitustion $S$ exists such that $S(\tau)$ = $\tau$'. \\

The syntax of operators and expressions is given bellow. The letter $v$ is used to denote values and the letter $x$ is used to dentote program variables. 
\begin{lstlisting}[numbers=none,frame=none]
op ::= addi | subi | multi | mini | maxi | addd | subd | 
       muld | mind | maxd | andb | orb | xorb |  nanb | 
       norb | notb | lti | ltei | gti | gtei | eqi | neqi |
       ltd | lted | gtd | gted | eqd | neqd | iota | each |
       reduce | i2d | b2i | reshape0 | reshape | rotate |
       transp | transp2 | zipWith | shape | take | drop |
       first | cat | cons | snoc | shapeV | catV | consV | 
       snocV | iotaV | rotateV | takeV | dropV | firstV 
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
e ::= $v$ 
    | $x$ 
    | $[\overrightarrow{e}]$ 
    | $e$ $e'$ 
    | let $x$ = $e_1$ in $e_2$ 
    | $op(\overrightarrow{e})$
\end{lstlisting}
A TAIL program always consists of a single expression. An expression can then be a value, variable, 
list of expressions, a let expression or an operator. Each TAIL operator has a unique type scheme. \\

One of the operators with a simple type scheme is the binary operator maxi that take two arguments $a$ and $b$ evaluates to the argument with the highest value. Its type scheme are as follows:
\begin{lstlisting}[numbers=none,frame=none]
maxi : int $\rightarrow$ int $\rightarrow$ int
\end{lstlisting}

Other operators have more complex type schemes. Examples of those are the parallel operators. 
There are four parallel operators in TAIL, {\tt each}, {\tt eachV}, {\tt reduce} and {\tt zipWith}.
The functions {\tt each} and {\tt eachV} are known in many languages as map.
The type scheme for the function {\tt each} is:
\begin{lstlisting}[numbers=none,frame=none]
each : $\forall\alpha\beta\gamma.(\alpha \rightarrow \beta)\rightarrow [\alpha]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
Given a function $f$ and an array $a$ {\tt each f a } evaluates to an array where $f$ is applied to each element of $a$ i.e. $[f(a_1),..,f(a_n)]$.
If the rank of the array is greater than 1 the {\tt each} function works as a map on the fattened representation of the array,
that is, the function is applied on the inner most dimension of the array, or seen in another way, on each basic value.

The {\tt eachV} function is a special case of {\tt each} and is used on vector types.\\

The function {\tt reduce} works similar to fold known from functional languages. The type scheme for {\tt reduce} is:
\begin{lstlisting}[numbers=none,frame=none]
reduce : $\forall\alpha\gamma.(\alpha \rightarrow \alpha \rightarrow \alpha)\rightarrow \alpha \rightarrow [\alpha]^{1 +\gamma} \rightarrow [\alpha]^{\gamma}$
\end{lstlisting}
The function takes as arguments a associative binary operator $op$ (for instance $+$), a neutral element $n$, (for instance 0) and array $a$.
The function application evaluates to the combination of the elements by the operator.
%It returns a value made from applying $+$  to first the netral element and the first element in $a$ and then to the result of the previus calculation and the next element in the array e.g. 0 $+$ $a_1$ $+$ ... $+$ $a_n$.
An array of rank $\gamma+1$ is reduced to an array of rank $\gamma$ along the inner-most dimension.
Unlike {\tt fold}, reduce makes no guarantees as to the order of application of the operator, therefore the operator has to be associative and the element has to be neutral, this is of course necessary for parrallel execution.\\

The {\tt zipWith} function's type scheme is given as follows: 
\begin{lstlisting}[numbers=none,frame=none]
zipWith  : $\forall\alpha_{1}\alpha_{2}\beta\gamma.(\alpha_1 \rightarrow \alpha_2 \rightarrow \beta)\rightarrow [\alpha_1]^{\gamma} \rightarrow [\alpha_2]^{\gamma} \rightarrow [\beta]^{\gamma}$
\end{lstlisting}
Given a function $f$ that works on a pair $(x,y)$ and two arrays $a_1$ and $a_2$, {\tt zipWith f a\_1 a\_2}  evaluates to an array where the n'th element is $f$ applied to the pair $({a_{1}}_n,{a_{2}}_n)$ 
Like the other three operators it works on the inner-most dimension of the array\cite{ElsmanDybdal:Array:2014}.\\

The background for designing TAIL was to create a typed intermediate language for the array programming language APL. TAIL is still under development and so is the {\tt apltail} compiler which compiles a subset of APL into TAIL \cite{ElsmanDybdal:Array:2014}.
APL is an older language created in the 1960's by Kenneth E. Iverson.
APL is an array programming language, its main type is the multi-dimensional array 
and most of the built-in functions in the language are array operators that work on this type. 
Most of its built-in functions or operators are represented by unicode symbols allowing for very concise code.
The APL language is dynamically typed. It supports first and second order functions and these functions work on arrays of any type. 
Even though it is an old language it is still used in the financial world 
where large code bases are still operational and actively developed \cite{ElsmanDybdal:Array:2014}. \\

TAIL was designed with the purpose of targeting parallel architectures such as GPUs and allows parallel programs to be
expressed in a highly abstract manner.
The TAIL compiler can also efficiently compile TAIL code into sequential code in a C-like language.
The subset of APL operators that TAIL support are shown earlier in this section.

The TAIL compiler infers types for the values in the APL program and can annotate bindings with
instance declarations. An instance declaration provides the base type and rank of the array. Or in
the case of vectors the size of the vector.

The language TAIL is statically typed and suports polymorphism. 
Most of the operators in TAIL are very general i.e. they are polymorphic with respect to array ranks and base types.
Although for some operations a specific type is needed.
An example is the {\tt take} function. It takes as argument a number (of type int) and an array of type $\alpha^\gamma$.\\

 TAILs type system takes the dynamicly types of APL and transforms it to a more manageable form adding explicit type
 information to the constructs.
Another benefit of the expressiveness of TAILs type system is that it allows the (TAIL) compiler to express some operators which
are primitive in APL using simpler operators, one such operator is that of the inner product \cite{ElsmanDybdal:Array:2014}. \\

The aplacc parser for TAIL represents the TAIL expressions in the abstract syntax tree as variables, constants, infinity, the negative representation of 
the expression, let expressions, operators and lambda expressions. 

TAIL does not support curried functions but require functions to be fully applied.

% In APL indexing are done with 1-indexing but it is possible to change the indexing to 0-indexing on the fly. 

%In TAIL the array type is a pair of a base type and a rank. The rank is a non-negative integer.
%The base type of an array is the type of the elements in the array and is one of the types
%: {\tt int}, {\tt double}, {\tt bool} {\tt char}. 
%Scalars are a special case of arrays and is considered an array of rank 0.
%Arrays of rank 1 are also called vectors and there is a separate type for vectors for which the size is known at compile time.
%This vector type is a pair of the base type and the length of the vector. The vector type is a subtype of arrays of rank 1 and
%the compiler may decide to replace the type for it's supertype when appropriate.


 %\cite{TorbenMogensen}. \\



%%If we do not show the type schemes here we should reference to where they can be found in the article!!!!!!!!!!

%The types in TAIL are divided into four types. Firstly there are base types consisting of {\tt int}, {\tt double}, {\tt bool} and the polymorphic type {\tt $\alpha$} that can represent any one of them. Secondly, there are shape types that can be either a scalar value/variable of type int,  or a shape variable or a combination of two shape variables. \\
%Then there is array types that consist of a base type and a rank. Finally there is 


%The main datatype in TAIL is also a multidimensional array. Array types are in TAIL annotated with their ranks explicitly. 
%TAILs type system treats scalar values as special cases of the array time namely an array with rank 0. 

%There are two separate representations of vectors, either the special vector type used when the length of the vector is known or the general array type where the rank is 1.  
 
%Besides array and vector types, TAIL also have base types in the form of {\tt int}, {\tt double}, {\tt bool} and {\tt $\alpha$}.

%So far TAIL only support a subset of the APL functions and operators. 


% THIS IS HOW THE COMPILER IMPLEMENTS EXPRESSIONS
%\begin{lstlisting}[numbers=none,frame=none]
%e ::= x | i | d | c | inf | -e | let x:$t$ = e$_1$ in e$_2$ |
%      op[e$_1$,...,e$_n$] | fn x:$t$ e | [e$_1$,...,e$_n$]
%\end{lstlisting}

%The 'V' following some of the operators indicate they are a special version of the operator that works on vectors. \\
%The $t$'s are types that are part of the expression. \\

\section{The functional language Futhark}

In this section we give a short introduction to the Futhark language, we will only cover the parts that are necessary to understand
the reasoning behind our compilation approach. For the full language reference please refer to (ref).

The syntax of Futhark types can be seen below.
\begin{lstlisting}[numbers=none,frame=none]
$t$   $::=$   int          (Integers)
    | real         (Float)
    | bool         (Booleans)
    | char         (Characters)
    | {$t_1$,...,$t_n$}      (Tuples)
    | [t]          (Arrays)
    | *[t]         (Unique arrays)
\end{lstlisting}
The types in Futhark consist of four base types: integers, floating points, booleans, tuples ({\tt \{t$_1$,...,t$_n$\}}), arrays ({\tt [t]}), and unique arrays ({\tt *[t]}).
Tuple types are written as a comma seperated list of types or values surrounded by braces. For example {\tt\{int,bool\}} is 
a pair of values of integer and boolean types.
Unline TAIL, Futhark allows nesting of arrays and indeed nested arrays are how multi-dimensional arrays are expressed in Futhark.
Array types are denoted by the elements (base) type enclosed by brackets.
The layer of brackets indicates the dimensionality of the array type.
For instance {\tt [int]} is a one-dimentional array of integers, and {\tt [[[bool]]]} is a tree-dimentional array of booleans.
Arrays must be regular, i.e. all arrays in an array must have the same numer of elements. \\

The Futhark language is statically typed but does not use type interference. Also the type system of Futhark is not 
able to express polymorphism, this means it is not possible to make polymorphic functions in Futhark.
The only exception is that a lot of the built-in functions can be used on multiple types.
The syntax of Futhark expressions are defined as follows:
\begin{lstlisting}[numbers=none,frame=none]
$k$ ::= $n$ | $x$ | $b$ | $c$ | {$v_1$,...,$v_n$} | [v$_1$,...,$v_n$] 
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$p$ ::= $id$ | {$p_1$,...,$p_n$}
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$e$ ::= $k$ | $v$ | {$e_1,...,e_n$} | [$e_1,...,e_n$] | $e_1$ $\odot$ $e_2$ |
      $-e$ | not $e$ | if $e_1$ then $e_2$ else $e_3$ | $v$[$e_1,...,e_n$] |
      $v$($e_1,...,e_n$) | let $p$ = $e_1 in e_2$ | zip($e_1,...,e_n$) | 
      unzip($e$) | iota($e$) | replicate($e_n, e_v$) | size($e$) |
      reshape(($e_1,...,e_n$),e) | transpose($e$) | split($e_1,e_2$) |
      concat($e_1,e_2$) | 
      let $v_1$ = $v_2$ with [$e_1,...,e_n$] <- $e_v$ in $e_b$  |
      loop ($p$ = $e_1$) = for $v$ < $e_2$ do $e_3$ in $e_4$ | map($l$, $e$) |
      filter($l$, $e$) |  reduce($l$, $x$, $e$) | scan($l$, $x$, $e$)
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$l$ ::=  fn $t$ ($t_1$ $v_1,..., t_n$ $v_n$) => $e$
    | $id$ ($e_1,...,e_n$)
    | op $\odot$ ($e_1,..., e_n$)
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$fun$ ::=  fun t v(t$_1$ v$_1$,...t$_n$ v$_n$) = $e$
\end{lstlisting}

\begin{lstlisting}[numbers=none,frame=none]
$prog$ ::= $\epsilon$ | $fun$ $prog$
\end{lstlisting}

All function declarations have global scope.

The functions {\tt map }, {\tt filter }, {\tt reduce } and {\tt scan } are second-order array combinators, or SOACs for short.
The SOACs operate on arrays with first-order functions given as arguments.
Functional arguments used can be function names of first-order functions (iether user-defind or built-in), 
binary operators, or lambda expressions.
Futhermore in a SOAC expression operators and functions can be curried. Lambda expressions require explicit type annotations for
the return type and argument types.

We do not target the SOACs {\tt filter} and {\tt scan} in our compilation, and as such will not discuss them here.
The SOACs can be used on arrays of any type even though it cannot be expressed by futhark types, for clarity we give the type for each SOAC that it would have had in a polymorphic language.
Below we shortly discuss {\tt map } and {\tt reduce }.
%Nedenfor er udkommenteret indtil vi finder plads til det igen
%Futhark is a functional programming language inspired by Haskell and Standard ML, it is mostly a first order language but supports bulk (parallel) operations on arrays
%using the built-in SOACs that are: {\tt map}, {\tt reduce}, {\tt filter}, and {\tt scan}.\\

%skal pendsles ud
%The functionality of the SOACs are what can be found in other functional languages such as Haskell or ML.

The function {\tt map} has the following type: 
\begin{lstlisting}[numbers=none,frame=none]
map : ($\alpha$ $\rightarrow$ $\beta$) $\rightarrow$ $[\alpha]$ $\rightarrow$ $[\beta]$
\end{lstlisting}
The function {\tt map($l$,$a$)} takes a function $l$ and an array $a$ and evaluates to the array consisting of $l$ applied to each element of $a$.
In contrast to TAIL, if the array is multi-dimensional the function is applied to the outer most dimension.
This means that if the function $l$ is maped into a 2-dimensional array the function would be aplied to an array not the elements
of the array. This makes sense considering that Futhark represents multi-dimensional arrays using nested arrays.\\

The type of the function {\tt reduce} is: 
\begin{lstlisting}[numbers=none,frame=none]
reduce : ($\alpha$ $\rightarrow$ $\alpha$ $\rightarrow$ $\alpha$) $\rightarrow$ $\alpha$ $\rightarrow$ $[\alpha]$ $\rightarrow$ $\alpha$
\end{lstlisting}
Given a binary operator/function $l$, the neutral element $e$ of $l$ and an array $a$,
{\tt reduce } evaluates to the result of applying $l$ to combine all the elements of $a$, i.e. 
\begin{lstlisting}[numbers=none,frame=none]
$e \odot a[0] \odot \ldots \odot a[n]$ where $x \odot y = l (x,y)$
\end{lstlisting}
Like {\tt map}, {\tt reduce} applies the function on the outer-most dimension of the array. \cite{TroelsHenriksen}.\\ 
% soacs tager l(kernel) som kan defineres pÃ¥ forskellige mÃ¥der og som kan curryes

%There are other built-in operators in Futhark besides the SOACs. The Futhark language support a number arithmetic 
%binary operators ($e_1$ $\odot$ $e_2$) for instance +, -, integer division, and integer modulo. The language also 
%support operators that work on arrays, for instance {\tt size} that takes an expression $e$ that can be eather one dimentional array (vector) or a multi-dimentional array and returns a comma seperated list containing the lenth of each dimention of $e$. If $e$ is a one-dimentional, the resurning list contains one element that is the length of the vector i.e. the number of elements. \\

The aim of Futhark is to be an attractive choice for expressing complex parallel programs.
This goal is pursued by featuring high expressive power without
losing the ability to do aggressive optimization and managing parallelism.
This is a challenge because higher expressive power means optimizations become more difficult. 
However Futhark does support nested parallelism as this is a feature many programs 
depend upon even though it does make optimization more difficult \cite{TroelsHenriksen}.

%%something more about specific optimization????????????????\\

% funktioner bliver inlinet

% funktioner skla definere returtype og type pÃ¥ alle argumenter


% indbyggede functioner som vi bruger og som faktisk er polymorfiske men de kan ikke types i futhark da futharks typesystem ikke kan udtrykke polymorphi.
%In general the Futhark language does not support polymorphism in functions,
%the only exception is the built-in second-order array combinators that work on arrays of any base type. 
%However this polymorphism can not be expressed in Futharks own type system.

%Does not support polymorfism in types

\section{The compilation scheme}

There main contribution with this paper is the compilation scheme presented in this section. It shows a detailed compilation of a subset of TAIL's operators to Futhark code. 
The compilation scheme is implementation independent and done in a form of mathematical notation. 
In this section both the compilation scheme and the notation is described. \\

On the left hand side of the scheme is the TAIL functions, the right hand side contains the Futhark expression they are translated to. An expression wraped in double brackets e.g. $\evals{x}$ signifies the compilation of the TAIL expression $x$.  \\

\begin{tabular}{l c l}% to \linewidth {l c X}
$\evals{x}$ & $=$ & $x$ \\
$\evals{i}$ & $=$ & $i$ \\
$\evals{d}$ & $=$ & $d$ \\
$\evals{c}$ & $=$ & $c$ \\
$\evals{-e}$ & $=$ & -$\evals{e}$ \\
$\evals{ \text{let } x:t = e_1 \text{ in } e_2} $ & $=$ & let $\evals{x} = \evals{e_1} \text{ in } \evals{e_2} $\\
$\evals{[e_1,...,e_n]}$ & $=$ & $ [ \evals{e_1},...,\evals{e_n}]$\\
$\evals{\text{op } [e_1,...,e_n]}$ & $=$ & $\evals{\text{op}}_{op} \evals{[e_1,...,e_n]}$\\

$\evals{\text{op} [e_1,...,e_n]}$ & $=$ & $\evals{\text{op}}_{fun} \; (\evals{e_1},...,\evals{e_n})$\\
$\evals{\text{op} [e_1,e_2]}$ & $=$ & $\evals{e_1} \; \evals{\text{op}}_{op} \; \evals{e_2}$\\

$\evals{\text{each}_{[t_1,t_2,r]}(f,a)}$ & $=$ & $
  \begin{cases}
    $map$(\evals{f}_{fn}^{\evals{t_2}},\evals{a}) & r=1\\
    $map (fn $t_2^r \; (t_1^r \; x)$ {\tt =>} $ \evals{\text{each}_{[t,r-1]}(f,x)},\evals{a}) & r > 1  \\
  \end{cases}$\\

$\evals{\text{eachV}_{[t_1,t_2,r]}(f,a)}$ & $=$ & map$(\evals{f}_{fn}^{\evals{t_2}},\evals{a}) $  \\         

$\evals{\text{vrotate}_{[t,r]}(i,a)}$ & $=$ & map(fn x {\tt =>} a[x + i {\tt \%} \text{size}(0,a)], iota(size(0,a)) \space\space , x = fresh\\
$\evals{\text{vreverse}_{[t,r]}(a)}$ & $=$ & map(fn x {\tt =>} a[\text{size}(0,a)-x-1], $\text{iota}(\text{size}(0,a))$ \space\space , x = fresh\\
$\evals{\text{reshape}_{[t,r_1,r]}(a_1,a_2)}$ & $=$ & reshape$(\evals{a_1},(\text{reshape1}_{\evals{t}}(
% \prod_{i=0}^{r_1} \text{size}(i,a_1)
\text{osize}%(\text{size}(0,a_1)*\ldots*\text{size}(r_1,a_1)
, \text{reshape}(
\text{isize}%\text{size}(0,a_2)*\ldots*\text{size}(r_2,a_2)
, \evals{a_2})))) $ \\
&& \hspace{4ex} where osize = $\text{size}(0,a_1)*\ldots*\text{size}(r_1,a_1)$ \\
&& \hspace{4ex} \phantom{where} isize = $ \text{size}(0,a_2)*\ldots*\text{size}(r_2,a_2) $ \\

$\evals{\text{reduce}_{[t,r]}(f,n,a)}$ & $=$ & $
  \begin{cases}
    \text{reduce}(\evals{f}_{fn}^{\evals{t}},\evals{n},\evals{a}) & r=1 \\
    $map (fn $ t^{r-1} \; (t^r \; x)$ {\tt =>} $ \evals{\text{reduce}_{[t,r-1]}(f,n,x)},\evals{a}) & r>1\\
  \end{cases}$\\

$\evals{\text{zipWith}_{[t_1,t_2,t_3,r]}(f,a_1,a_2)}$ & $=$ & \\
  \multicolumn{3}{r}{ $\begin{cases}
    $map$(\evals{f}_{fn}^{\evals{t_3}},$zip($\evals{a_1},\evals{a_2})) & r=1 \\
    $map(fn $t_3^{r-1} \; (t_1^{r-1} \; x, t_2^{r-1} \; y) $ {\tt =>} $
      \evals{\text{zipWith}_{[t_1,t_2,t_3r-1]}(f,x,y)} , $zip($ \evals{a_1}, \evals{a_2})) & r>1\\
  \end{cases}$ }\\

$\evals{\text{cat}_{[t,r]}(a_1,a_2)}$ & $=$ & $
  \begin{cases}
    \text{concat}(\evals{a_1},\evals{a_2}) & r=1 \\
    $map (fn $ \evals{t}^{r-1} \; (\evals{t} \; x, \evals{t} \; y)$ {\tt =>} $ \evals{\text{cat}_{[t,r-1]}(x,y)}, \text{zip}(\evals{a_1}, \evals{a_2}) & r>1\\
  \end{cases}$\\

$\evals{\text{first}_{[t,r]}(a)}$ & $=$ & let x = $\evals{a}$ in $x[\underbrace{0,...,0}_\text{r times}]$\\

$\evals{\text{firstV}_{[t,r]}(a)}$ & $=$ & $\evals{\text{first}_{t,1}(a)}$\\

$\evals{\text{take}(i,a)}$ & $=$ & reshape(oshape,\text{take1}$_{\evals{t}}$(osize,\text{reshape}(isize,$\evals{a})))$\\
&& \hspace{4ex} where oshape = ($|i|, \text{size}(1,\evals{a}),\cdots,$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} osize = ($i* \text{size}(1,\evals{a}) *\ldots*$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} isize = \text{size}(0,$\evals{a}$)$*\ldots*$\text{size}(r,$\evals{a}$)\\

$\evals{\text{takeV}_t(d,a)}$ & $=$ & $\text{take1}_{\evals{t}}(\evals{d},\evals{a})$\\

$\evals{\text{drop}(i,a)}$ & $=$ & \text{reshape}(\text{oshape}, $\text{drop1}_{\evals{t}}(\text{osize}, \text{reshape}(\text{isize},\evals{a}))$\\
&& \hspace{4ex} where oshape = (max(0,size(0,$\evals{a}$)-$|i|$),size(1,$\evals{a}$)$,\ldots,$size(r,$\evals{a}$))\\
&& \hspace{4ex} \phantom{where} osize = ($i *$size(1,$\evals{a}$)$ * \ldots*$size(r, $\evals{a}$))\\
&& \hspace{4ex} \phantom{where} isize = \text{size}(0,$\evals{a}$)$*\ldots*$\text{size}(r,$\evals{a}$)\\

$\evals{\text{dropV}_t(d,a)}$ & $=$ & $\text{drop1}_{\evals{t}}(\evals{d},\evals{a})$\\

$\evals{\text{transp}_{t,r}(a)}$ & $=$ & rearrange$((r-1,...,0),\evals{a})$\\

$\evals{\text{transp2}_{t,r}(a_1,a_2)}$ & $=$ & let $x$ = $\evals{a_1}$ in rearrange(($x[0]$-$1,\ldots,x[r$-$1]$-$1$),$\evals{a_2})$\\

%$\evals{\text{cons}_[t,r](e,a)}$ & $=$ &  
%  $\begin{cases}
%    \text{concat}([\evals{e}],\evals{a}) & r= 1\\
%    \text{map (fn }$$(x,y) $ {\tt =>} $ \evals{\text{cons}_{[t,r]}(x,y)}, \text{ zip}(\evals{e},\evals{a}))$$ & r > 1
%  \end{cases}$\\

$\evals{\text{cons}_[t,r](e,a)}$ & $=$ & rearrange$((r,\ldots,0), \text{concat(exp,arr)})$\\
&& \hspace{4ex} where exp = rearrange((r-1,\ldots,0),$\evals{e}$)\\
&& \hspace{4ex} \phantom{where} arr = rearrange((r-1,\ldots,0),$\evals{a}$)\\
  
$\evals{\text{snoc}_[t,r](a,e)}$ & $=$ & rearrange$((r,\ldots,0), \text{concat(arr,exp)})$\\
&& \hspace{4ex} where exp = rearrange((r-1,\ldots,0),$\evals{e}$)\\
&& \hspace{4ex} \phantom{where} arr = rearrange((r-1,\ldots,0),$\evals{a}$)\\
  
%$\evals{\text{snoc}_[t,r](a,e)}$ & $=$ & 
%  $\begin{cases}
%    \text{concat}([\evals{a}],\evals{e}) & r= 1\\
%    \text{map (fn }$$(x,y) $ {\tt =>} $ \evals{\text{snoc}_{[t,r]}(x,y)}, \text{ zip}(\evals{a},\evals{e}))$$ & r > 1
%  \end{cases}$\\

$\evals{\text{iota}(a)}$ & $=$ & map$(+ \; (1), \text{iota}(\evals{a})$\\

$\evals{\text{iotaV}(a)}$ & $=$ & $\evals{\text{iota}(a)}$\\

$\evals{\text{shape}_{t,r}(a)}$ & $=$ & $[\text{size}(0,\evals{a}),...,\text{size}(r-1,\evals{a})]$\\

$\evals{\text{shapeV}_{t,r}(a)}$ & $=$ & $[r]$\\
\\
%\end{tabular}\\
%
%The compilation of fn are descirbed in a table of its own\\
%
%\begin{tabular}{l c l}
$\evals{ \text{fn } x:t $ {\tt =>} $ e}^{\tau}_{fn} $ & $=$ & $ \text{fn } \tau (\evals{t}\; x) $ {\tt =>} $ \evals{e}$\\
$\evals{ \text{fn } x:t_1$ {\tt =>} $\text{fn } y:t_2 $ {\tt =>} $ e}^{\tau}_{fn} $ & $=$ & $ \text{fn } \tau (\evals{t_1}\; x, \evals{t_2} \; y) $ {\tt =>} $ \evals{e}$\\
\end{tabular}\\

The gereral compilation of operators:\\

\begin{tabular}{l c l}
$\evals{addi}_{op}$ & $=$ & $+$\\
$\evals{i2d}_{fun}$ & $=$ & toReal\\ 
\end{tabular}\\

Some TAIL expressions have type information as part of their declaration. This type information can be seen in the
compilation scheme as subscript to the function. The type information can be either just a type $t$ or a combination of both type and rank $r$. The type consist of a type that are one of the TAIL
types described in section 2. The rank is the number of dimentions.  \\

Type information can also be represented by $\tau$, but only in the special case of anonymus functions (fn) where it 
indicate the return type of the anonymus function. This types is not an apparent part of the anonymus function in TAIL
but the type information exist as part of the function that calls the internal function. Therefore the return type is simply 
pased through to the internal anonymus function. \\

The letters $x$, $i$, $d$, and $c$ dentoes variables, integers, doubles, and chars respectively. BOOLEANS MANGLER!!!!!!


\section{Testing}
We have applied two types of testing in our project. One if a form of correctness test set op as an automated test
framework, the other is to test the efficiency of the generated test in form of benchmarks. 

\subsection{Automated testframework}
In order to test the correctness of the the generated code we have set up a test using the Cabal framework to make automatet tests that take the TAIL code though the tail2futhark compiler and the Futhark compiler and compair the result from the Futhark compiler with a premade result file containing the correct result. The automated test made it possible to run all tests whenever we did an alteration to the compiler. 
Running the tests every time we made an alteration enabled us to check if the new alteration had created a problem with the work we had allredy done. \\

We have the tests in a directory called {\tt test/ourtests} in the {\tt tail2futhark} project. \\

%We have not done thorough testing on all the fuctions implemented in the compiler as that is a very time consuming task. 
To test that our implementation of the TAIL functions work correctly we have created test to see if the function:
\begin{itemize}
\item works on different data types
\item work on edgecases
\item works on positive and negative input
\item function correct in all branches in if-then-else expressions
\end{itemize}
In order to thoroughly test the compiler all functions should be have specific test that test one of each of the above things
that meaningfully apply to the function. \\

We have not testet for or taken into account the possibility of TAIL code that are incorrect as it is generated by a compiler and only used as an intermidiate language. 

Because of the importance of the multidimentional arrays for the language we have testet each function on input of 1 dimention and input of at least 2 dimentions. 

\subsection{Benchmarks}
We have used benchmarks to mesure preformance of the generated Futhark code by comparing it with the TAIL code.
Because no parallel backend are finished for either TAIL or Futhark we use a sequential backend for both languages. \\

We have used the 


One of the benchmarks we used was matrix multiplication. The code in TAIL can be seen below. 

\begin{lstlisting}
let v0:[int]2 = reshape{[int],[1,2]}([3,2],iotaV(5)) in
let v1:[int]2 = transp{[int],[2]}(v0) in
let v6:[int]3 = transp2{[int],[3]}([2,1,3],
                     reshape{[int],[2,3]}([3,3,2],v0)) in
let v12:[int]3 = transp2{[int],[3]}([1,3,2],
                     reshape{[int],[2,3]}([3,2,3],v1)) in
let v17:[int]2 = reduce{[int],[2]}(addi,0,
                zipWith{[int,int,int],[3]}(muli,v6,v12)) in
let v22:[int]0 = reduce{[int],[0]}(muli,1,
                 reduce{[int],[1]}(addi,0,v17)) in
i2d(v22)
\end{lstlisting}

It becomes the following Futhark code when run through the compiler.

\bibliography{references}{} 
\bibliographystyle{plain}

\end{document}
