\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{listings}
\usepackage{setspace}

\definecolor{Background}{rgb}{0.98,0.98,0.98}
\lstset{
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=1em,
    xleftmargin=1em,
    framextopmargin=2em,
    framexbottommargin=2em,
    showspaces=false,
    showtabs=false,
    showstringspaces=false,
    frame=l,
    tabsize=4,
    % Basic
    basicstyle=\ttfamily\small\setstretch{1},
    backgroundcolor=\color{Background}
}

\author{
  \Large{Anna Sofie Kiehn}
  \\ \texttt{a.kiehn@gmail.com} \\ \\
  \Large{Henriks Urms}
  \\ \texttt{urmshenrik@gmail.com}
}

\title{
  \vspace{3cm}
  \Huge{Bachelorproject} \\
  \Large{Compiling TAIL to Futhark}
}

\begin{document}

%% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
%% `natbio-farve` to use SCIENCE's new colors and logo.
\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{include/ku-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{include/ku-farve}}}

%% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
\AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

\clearpage\maketitle
\thispagestyle{empty}

\newpage

\section{Abstract}

\section{Introduction}
In recent years, there has been a lot of focus on leveraging the power of parallel hardware. 

One approach has been to design programming languages with explicit data-parallel constructs that can be compiled into highly parallel code. One such language is Futhark. The aim of Futhark is to target parallel hardware such as GPUs while itself being the target of more programmer-productivity oriented languages. The Futhark compiler performs several optimizations, such as fusion, which enhance the degree of parallelism [4].

Any language that targets Futhark must have a compiler that is capable of extracting parallelism or must be able to express parallelism directly in the source code to be able to leverage the parallel constructs of Futhark.

A language that expresses data-parallelism very well is APL. APL is a mature language developed in the 1960s but still used today e.g. in financial applications. In APL, the programmer is able to express complex programs in a concise manner using a very compact notation.

Efforts in compiling APL to parallel backends already exist in the form of the language TAIL(Typed array intermediate language) and itâ€™s compiler. The TAIL compiler captures the parallelism inherent in APL source code and brings it to a much more manageable form. In our work we provide a compiler from TAIL to Futhark thus bridging the gap between APL and Futhark. While doing  this, we will focus on generating efficient code. In particular, we will try to preserve the parallelism in the source code.

\section{Overview of TAIL}
Tail is a typed intermidiate language to the multidimentional array language APL (reference). Tail is designed as a practical and well-defined intermidiate format for targeting parallel architectures.\\ 

The types in Tail consist of types that classify shapes i.e. multidimentional arrays, vector types that are a special case of the shape type where the rank of the array is 1 and the length is staticly known and singleton types that like vectors are a special case of array type with rank 0. 

Tail implements a subset of the array operators found in APL.
Besides shape (multidimentional array) and vector types Tail has primitive types such as \verb|int|, \verb|double| and \verb|bool|.

\section{Overview of Futhark}
Futhark is a functionel language, created to be an independent language designed for parallel exectution. In order to be better suted for compiler optimisation such as transposition and simplefied size analysis Futhark only support nested parallelism on regular arrays i.e. arrays where all rows have the same length.\\

The reason Futhark support nested parallelism insted of just flat parallelism is that many programs includes several layers of parallellism and this cannot be exploided using flat parallelism %[in the stile if REPA see troelses speciale p 4]

\section{The difference betweet TAIL and Futhark}
There are no tubles in TAIL and therefore the pattern constructor will be used only to create id's wich is realy just a variable name. Therefore it was decided not to implement the pattern constructor in the Futhark AST and instead use the identifyer in the form of an var with type Ident (that has type String). \\

One of the main differences between TAIL and Futhark is the implementation of the array operators...???????? \\
\begin{figure}
\begin{lstlisting}
fun [int] takeV(int l, [int] x) =
  if 0 <= l then
      if l <= size(0,x) then
          let {v1,v2} = split(l,x) in v1
      else
          concat(x,replicate(l - size(0,x),0))
  else
  
      if -l <= size(0,x) then
          let {v1,v2} = split(size(0,x)+l,x) in v2
      else
          concat(replicate(-(size(0,x)+l),0),x)
\end{lstlisting}
\end{figure}
\section{The compilation scheme}
An overview of the combilation scheme can be found in figure ???????. 

\subsubsection{shape}
\verb|shape| is implemented by mapping \verb|size| on each of the dimentions and then wrapping the resulting array in the Futhark array type constructor. 
\verb|shape| could potentialy be used on multidimentional array of a high number of dimentions resulting in a very long computation time but our implementation does not support an efficient implementation in this case. In order to have an efficient implementation when the number of dimentons are very high is to use \verb|reshape| .... \\

\subsubsection{take and drop}
\verb|take| and \verb|drop| are both implemented

\subsection{Buildinds}
Futhark transforms all functions to fist level functions and in order to simplefy the implementation of some functions for instance \verb|take| it was made a build in function added to the beginning of every program. The sucsequent problem of removing the dead code in the programs where these functions is not used we hand of to the compiler.


%is implemented by wrapping a maped haskell array in the futhark array constructor. The reason for this is the to prevent a havy computation in the case where the array has a big number of dimentions. Alternativly \verb|| 

\section{Methods}
\section{Evaluation}
\subsection{Test results}
\subsection{Discusion}
Futhark does not allow for the creation of functions that has polymorphic (return) types. Only the build in functions support polymorphism. That created a problem when we had to implement some of the array combinators for instance  \verb|take| because in order to make it work on an array of arbitrary rank we either had to create a `libaray' function for each of the ranks, or create a function that could give us the return type that luckaly is the same for \verb|take| as the type it is given or we could....... 
We therefore limited our compiler to only support \verb|take| operations on array with rank \(< \) 4. \\ %not true!!

This could be remidied by instead compiling the exact code from the Tail program to Futhark code, but that would create a somewhat complicated translation cheme and would be difficult to implement in the compiler????????? %not sure this is true just writing crap...
However this is only needed because Futhark does not support polymorphism in fuctions. If it did it would be easy to simply translate the Tail code to the corresponding Futhark code.

Builtin aux functions >< inline expressions in cases of reshape, take, drop mm.!!!!!!!!1!!!!!!!!!!!!??????????????????

\section{Conclusion}

%\section{Adapting the parser}
%Instead of writing a parser from scratch we instead adabbted an existing one writen to support an accelerate backend for Haskell. 

%\section{Compiler}
%Because TAIL is a much less extencive language then Futhark we decided to base our implementation in the compiler thereby trying to minimise making code we will later discover we will not need because a structure that exists in Futhark doen not exist in TAIL and we therefore will not need to compile it. 

%\subsection{Constants}
%TAIL does not support \verb|fint| so that is not implemented. 
\end{document}
